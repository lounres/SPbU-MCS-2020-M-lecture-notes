\documentclass[12pt,a4paper]{article}
\usepackage{../.tex/mcs-notes}
\usepackage{todonotes}
% \usepackage{multicol}
\usepackage{float}

\settitle
{Теоретическая информатика.}
{\href{https://users.math-cs.spbu.ru/~okhotin/}{А.С. Охотин},
Э.А. Гирш и
Д.О. Соколов}
{\%D0\%A2\%D0\%98/MA.pdf}
\date{}

% \DeclareMathOperator{\Quot}{Quot}
% \DeclareMathOperator*{\osc}{osc}
% \DeclareMathOperator{\sign}{sign}
% \DeclareMathOperator{\const}{const}
% \DeclareMathOperator{\grad}{grad}
% \newcommand{\eqdef}{\mathbin{\stackrel{\mathrm{def}}{=}}}
% \newcommand{\True}{\mathrm{True}}
% \newcommand{\False}{\mathrm{False}}
% \newcommand{\Id}{\mathrm{Id}}
% \renewcommand{\Re}{\mathrm{Re}}
% \renewcommand{\Im}{\mathrm{Im}}
\newcommand{\spacesymbol}{\ensuremath{\text{\textvisiblespace}}}

\begin{document}
    \maketitle

    \listoftodos[TODOs]

    \tableofcontents

    \vspace{2em}
    Литература:
    \begin{itemize}
        \item \dots
    \end{itemize}

    Страницы курса:
    \begin{itemize}
        \item \href{https://users.math-cs.spbu.ru/~okhotin/teaching/tcs_fl_2021/}{Часть курса}, прочитанная А.С. Охотиным.
    \end{itemize}
    
    \section{Вычислимость}

    \begin{definition}
        \emph{Машина Тьюринга} --- это реализация понятия вычисления. Она заключается в том, что имеется бесконечная в обе стороны клетчатая лента с записанным на ней конечным словом (по букве на клетку) --- входные данные вычисления --- и головка --- вычисляющий аппарат, которая в каждый момент времени смотрит на какую-то клетку ленты и имеет в себе некоторое внутреннее состояние вычислений. Каждым своим действием она читает символ в клетке, на которую смотрит, и в зависимости от прочитанного символа и внутреннего состояния в данный момент она пишет в клетку, на которую смотрит новый символ, стирая старый, переходит на новую клетку и меняет внутренне состояние.

        Формально машина Тьюринга $M$ --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$ --- (конечного) алфавита входных данных,
            \item рабочего алфавита $\Gamma$ --- (конечного) алфавита, над которым мы работаем, что $\Gamma \supseteq \Sigma \sqcup \{\spacesymbol\}$,
            \item конечного множества (внутренних) состояний $Q$,
            \item начального состояния $q_0 \in Q$,
            \item функции переходов $\delta: Q \times \Gamma \to Q \times \Gamma \times \{-1; +1\}$
            \item и дополнительных объектов и условий в зависимости от предназначения машины.
        \end{itemize}
        Входными данными программы является конечная строка $s_1 \dots s_l$, которая превращается в запись $\{a_i\}_{i \in \ZZ}$ на ленте по правилу
        \[
            a_i
            = \begin{cases}
                s_{i+1}& \text{ если } 0 \leqslant i \leqslant l-1,\\
                \spacesymbol& \text{ иначе.}
            \end{cases}
        \] 
        Состояние каждого момент вычисления --- это совокупность
        \begin{itemize}
            \item состояния ленты $\{a_i\}_{i \in \ZZ}$, где $a_i \in \Sigma$ и все $a_i$ кроме конечного числа элементов являются пробелом \spacesymbol,
            \item положения головки $n \in \ZZ$ на ленте и
            \item состояния головки $q \in Q$.
        \end{itemize}
        Состояние начального момента вычислений образуется из
        \begin{itemize}
            \item состояния ленты, полученного из входных данных,
            \item положения головки по умолчанию $n = 0$
            \item начального состояния головки $q_0$.
        \end{itemize}
        Каждым шагом состояние $(\{a_i\}_{i \in \ZZ}, n, q)$ заменяется на состояние $(\{a'_i\}_{i \in \ZZ}, n', q')$, где $a'_i = a_i$ для всех $i \in \ZZ \setminus \{n\}$ и
        \[
            (q', a'_n, n'-n) := \delta(q, a_n).
        \]

        Далее есть два вида предназначений машины:
        \begin{enumerate}
            \item \textbf{Распознование свойства.} В этом случае мы хотим уметь распознавать разные конечные строки, т.е. чтобы машина отвечала ``да'' или ``нет'' на вопрос ``Лежит ли эта строка в заданном семействе?''. В таком случае у машины выделяются \emph{принимающее состояние} $q_{acc} \in Q$ и \emph{отвергающее состояние} $q_{rej} \in Q$, и когда машина переходит в одно из этих двух состояний, вычисления прекращаются. В таком случае $\delta(q, a)$ должно быть не определено в случае $q \in \{q_{acc}; q_{rej}\}$.
            \item \textbf{Вычисление функции.} В этом случае мы хотим вычислять значение некоторой функции $M: \Sigma^* \to \Sigma^*$, т.е. чтобы машаина после некоторого количества действий говорила ``Готово.'' и оставляла на ленте конечное слово в том же формате, в котором производится ввод. В таком случае у машины выделяется \emph{состояние останова} $q_{halt} \in Q$, и когда машина переходит в это состояние, вычисления прекращаются, а на ленте должно остаться слово в правильном формате. В таком случае $\delta(q, a)$ должно быть не определено в случае $q = q_{halt}$.
        \end{enumerate}
    \end{definition}

    \begin{remark*}
        Фактически множество результатов работы машины состоит из переходов в одно из терминальных состояний ($q_{acc}$, $q_{rej}$ или $q_{halt}$) и попадание в ``вечный цикл''.
    \end{remark*}

    \begin{theorem}
        В определении машина Тьюринга множество возможных смещений головки $\{+1; -1\}$ можно сменить на некоторое $S \subseteq \ZZ$. Тогда если $S$ конечно и всякое целое число представляется в виде суммы хотя бы одного значения (возможно, с повторами) из $S$, то определение получается равносильным.
    \end{theorem}

    \begin{proof}
        Действительно, пусть у нас имеется машина с множеством возможных сдвигов $S_1$, а у нас есть множество возможных сдвигов $S_2$, что всякое число из $S_1$ представляется в виде суммы некоторых (хотя бы одного и, возможно, с повторениями) членов из $S_2$. Тогда для всякой перехода между состояниями $q_1 \to q_2$ можно создать такие фальшсостояния, что смещение на значение из $S_1$ будет заменено на несколько смещений на значения из $S_2$ с тем же итогом. Таким образом мы можем всякую машину на $S_1$ поменять на машину на $S_2$ и большим числом состояний.
        
        Таким образом множества смещений $S_1$ и $S_2$ реализуют равносильные модели, если всякое значение из $S_1$ расскладывается в сумму значений $S_2$ и наоборот. При для $S_1 = \{+1; -1\}$ переход $S_2 \to S_1$ очевиден, а переход $S_1 \to S_2$ означает, что $1$ и $-1$ раскладываются в суммы некоторых чисел из $S_2$, что равносильно разложимости всякого целого.
    \end{proof}

    \begin{corollary}
        Вместо $\{+1; -1\}$ для удобства можно также подразумевать $\{+1; 0; -1\}$.
    \end{corollary}

    \begin{remark*}
        В данный момент мы будем рассматривать только задачу распознавания свойства.
    \end{remark*}

    \begin{definition}
        \emph{Язык машины} $M$ или \emph{язык, распознаваемый машиной $M$,} --- это множество $L(M) \subseteq \Sigma^*$ входных строк, которые машина принимает. Т.е. это множество всех конечных строк $w \in \Sigma^*$ таких, что машина $M$ на входе $w$ завершает работу и принимает данный вход.

        Язык, распознаваемый какой-нибудь машиной, называется \emph{рекурсивно-перечислимым}.

        Язык, распознаваемый какой-нибудь машиной, которая останавливается на любом входе, называется \emph{рекурсивным}.
    \end{definition}

    \begin{example}
        Пусть $\Sigma = \{a; b\}$, $L = \{a^nb ^n\}_{n \geqslant 0}$. Тогда $L$ распознаётся машиной Тьюринга (которая причём останавливается на всяком входе!).

        Действительно, давайте напишем машину, которая будить ездить из одного конца нашей строки в другую и стирать $a$ справа и $b$ слева, и, если получит пустую строку, примет вход, а если поймет, что в какой-то момент получается что-то неправильное, то отвергнет вход. Формально, возьмём $Q = \{q_0; q_1; q_2; q_3; q_{acc}; q_{rej}\}$ и $\Gamma = \{a; b; \spacesymbol\}$, а функцию перехода опишем следующей таблицей:
        \begin{table}[H]
            \centering
            \begin{tabular}{c||c|c|c}
                $Q\backslash\Gamma$& $a$& $b$& $\spacesymbol$\\
                \hline
                \hline
                $q_0$& $q_1$, \spacesymbol, $+1$& $q_{rej}$& $q_{acc}$\\
                \hline
                $q_1$& $q_1$, $a$, $+1$& $q_1$, $b$, $+1$& $q_2$, \spacesymbol, $-1$\\
                \hline
                $q_2$& $q_{rej}$& $q_3$, \spacesymbol, $-1$& $q_{rej}$\\
                \hline
                $q_3$& $q_3$, $a$, $-1$& $q_3$, $b$, $-1$& $q_0$, \spacesymbol, $+1$\\
            \end{tabular}
        \end{table}
        Т.е. во с помощью $q_0$ и $q_2$ мы стираем $a$ слева и $b$ справа соответственно, а с помощью $q_1$ и $q_2$ перемещаемя до конца вправо и влево соответственно.
    \end{example}

    \begin{theorem}
        Есть язык, нераспознаваемый никакой машиной Тьюринга.
    \end{theorem}

    \begin{proof}
        Несложно видеть, что для всякого конечного непустого алфавита $\Sigma$ количество $|\Sigma^*|$ конечных строк над $\Sigma$ счётно, а значит языков над $\Sigma$ континуум. При этом машин Тьюринга с входным алфавитом $\Sigma$ счётное число. Значит почти все языки не распознаются машинами Тьюринга.

        При этом есть довольно простые конкретные примеры нераспознаваемых языков.
    \end{proof}

    \begin{definition}
        \emph{Запись $\sigma(M)$ машины Тьюринга $M$} --- это конечной битовая строка, созданная по следующему правилу. Пусть у машины $M = (\Sigma, \Gamma, Q, q_0, \delta, q_{acc}, q_{rej})$
        \begin{itemize}
            \item $\Sigma = \{a_1; \dots; a_l\}$,
            \item $\Gamma = \Sigma \cup \{a_{l+1}; \dots; a_m\}$, где причём $a_m = \spacesymbol$,
            \item $Q = \{q_0; \dots; q_{n-1}\}$, где причём $q_{acc} = q_{n-2}$, $q_{rej} = q_{n-1}$.
        \end{itemize}
        Тогда запишем всё в унарной системе счисления, т.е. (всякий абстрактный) массив числовых данных будет храниться в виде последовательностей единиц, длины которых будут равняться соответствующим значениям массиве, разделённых нулями. Тогда машина $M$ будет записана строкой
        \[\sigma(M) := 1^l\, 0\, 1^m\, 0\, 1^n\, 0 \prod_{\delta(q_i, a_j) = q_{i'}, a_{j'}, d} 1^i\, 0\, 1^j\, 0\, 1^{i'}\, 0\, 1^{j'}\, 0\, 1^{d+1}\]
        (где умножение, безусловно, --- конкатенация, а $\prod$ --- конкатенация нескольких строк).
    \end{definition}

    \begin{definition}
        Языки $L_0$ и $L_1$ --- это
        \[
            L_0 := \{\sigma(M) \mid \sigma(M) \notin L(M)\}
            \qquad \text{ и } \qquad
            L_1 := \{\sigma(M) \mid \sigma(M) \in L(M)\}.
        \]
    \end{definition}

    \begin{theorem}\ 
        \begin{enumerate}
            \item $L_0$ не рекурсивно-перечислимый.
            \item $L_1$ рекурсивно-перечислимый.
            \item $L_1$ рекурсивный.
        \end{enumerate}
    \end{theorem}

    \begin{proof}
        \begin{enumerate}
            \item Предположим противное, т.е. есть машина $M$, распознающая $L_0$. Тогда если $M$ принимает $\sigma(M)$, то $\sigma(M) \in L(M)$, но тогда $\sigma(M) \notin L$. Если же $M$ не принимает $\sigma(M)$, то $\sigma(M) \notin L(M)$, но тогда $\sigma(M) \in L$. Противоречие наподобие парадокса Рассела. Значит нет никакой машины, распознающей $L_0$.
            \item Неформально опишем машину, которая будет распознавать $L_1$. Идея машины заключается в том, что получая на вход $\sigma(M)$, после этого запсанного кода машины $M$ она запишет код начального состояния $q_0$ машины $M$, а затем код $\sigma(M)$ как входную строчку для $M$. После этого она начнёт моделировать работу машины $M$ на входе $\sigma(M)$. Состояние головки будет писаться перед клеткой, на которую головка смотрит. Если места слева будет не хватать, то вся запись будет просто сдвигаться вправо.
            \item Покажим, что всякая машина, распознающая $L_1$ зацикливается при некотором входе. Предположим противное, т.е. есть машина $\widetilde{M}$, которая распознаёт $L_1$ и всегда остансавливается. Тогда построим $\widehat{M}$ по алгоритму:
                \begin{itemize}
                    \item Проверить правда ли, что на было подано некоторое $\sigma(M)$. Если нет, то отвергнуть.
                    \item Работать как $\widetilde{M}$ на $\sigma(M)$. Если $\widetilde{M}$ принимает, то отвергнуть. Если отвергает --- принять.
                \end{itemize}
                Тогда $\widehat{M}$ распознаёт $L_0$ --- противоречие. Значит машины $\widetilde{M}$ не существует.
        \end{enumerate}
    \end{proof}
    
    \begin{theorem}
        Язык
        \[L_\varnothing := \{\sigma(M) \mid L(M) = \varnothing\}\]
        не рекурсивно-перечислимый.
    \end{theorem}

    \begin{proof}
        Предположим противное, т.е. есть машина $M_\varnothing$, которая распознаёт $L_\varnothing$. Тогда построим машину $M_0$ по следующему алгоритму.
        \begin{enumerate}
            \item Проверить правда ли, что на было подано некоторое $\sigma(M)$. Если нет, то отвергнуть.
            \item Построить $\sigma(M')$, где машина $M'$ работает по следующему алгоритму.
                \begin{itemize}
                    \item Стереть входную строку.
                    \item Написать $\sigma(M)$.
                    \item Запустить $M$.
                \end{itemize}
            \item Запустить $M_\varnothing$ на $\sigma(M')$.
        \end{enumerate}
        $M'$ принимает любую строку, если $M$ принимает $\sigma(M)$, отвергает любую строку, если $M$ отвергает $\sigma(M)$, и зацикливается, если $M$ зацикливается на $\sigma(M)$. Следовательно $M_\varnothing$ примет $\sigma(M')$ тогда и только тогда, когда $\sigma(M) \notin L(M)$. Таким образом $M_0$ распознаёт $L_0$.
    \end{proof}

    \begin{definition}
        Для всякого свойства $P$ языков можно определить язык
        \[L_P := \{\sigma(M) \mid \text{$L(M)$ обладает свойством $P$}\}.\]
    \end{definition}

    \begin{example}\ 
        \begin{enumerate}
            \item Если $P$ --- это ``непустота'', то
                \[L_P := \{\sigma(M) \mid L(M) \neq \varnothing\}.\]
                Такой язык рекурсивно-перечислим.
            \item
                \[L_P := \{\sigma(M) \mid \text{$M$ отвергает конечное число программ на C++}\}.\]
            \item
                \[L_P := \{\sigma(M) \mid L(M) = L_0\}.\]
                Как мы уже знаем $L_P = \varnothing$.
        \end{enumerate}
    \end{example}

    \begin{theorem}[Райса]
        Всякое нетривиальное свойство неразрешимо.
    \end{theorem}

    % \section{Языки и автоматы}
    % \section{Сложность вычислений}
    % \section{Теория информация}
\end{document}