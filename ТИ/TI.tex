\documentclass[12pt,a4paper]{article}
\usepackage{../.tex/mcs-notes}
\usepackage{todonotes}
% \usepackage{multicol}
\usepackage{float}

\settitle
{Теоретическая информатика.}
{\href{https://users.math-cs.spbu.ru/~okhotin/}{А.С. Охотин},
Э.А. Гирш и
Д.О. Соколов}
{\%D0\%A2\%D0\%98/MA.pdf}
\date{}

% \DeclareMathOperator{\Quot}{Quot}
% \DeclareMathOperator*{\osc}{osc}
% \DeclareMathOperator{\sign}{sign}
% \DeclareMathOperator{\const}{const}
% \DeclareMathOperator{\grad}{grad}
% \newcommand{\eqdef}{\mathbin{\stackrel{\mathrm{def}}{=}}}
% \newcommand{\True}{\mathrm{True}}
% \newcommand{\False}{\mathrm{False}}
\newcommand{\Id}{\mathrm{Id}}
% \renewcommand{\Re}{\mathrm{Re}}
% \renewcommand{\Im}{\mathrm{Im}}
\newcommand{\spacesymbol}{\ensuremath{\text{\textvisiblespace}}}
\newcommand{\RE}{\mathrm{RE}}

\begin{document}
    \maketitle

    \listoftodos[TODOs]

    \tableofcontents

    \vspace{2em}
    Литература:
    \begin{itemize}
        \item \dots
    \end{itemize}

    Страницы курса:
    \begin{itemize}
        \item \href{https://users.math-cs.spbu.ru/~okhotin/teaching/tcs_fl_2021/}{Часть курса}, прочитанная А.С. Охотиным.
    \end{itemize}
    
    \section{Вычислимость}

    \begin{definition}
        \emph{Машина Тьюринга} --- это реализация понятия вычисления. Она заключается в том, что имеется бесконечная в обе стороны клетчатая лента с записанным на ней конечным словом (по букве на клетку) --- входные данные вычисления --- и головка --- вычисляющий аппарат, которая в каждый момент времени смотрит на какую-то клетку ленты и имеет в себе некоторое внутреннее состояние вычислений. Каждым своим действием она читает символ в клетке, на которую смотрит, и в зависимости от прочитанного символа и внутреннего состояния в данный момент она пишет в клетку, на которую смотрит новый символ, стирая старый, переходит на новую клетку и меняет внутренне состояние.

        Формально машина Тьюринга $M$ --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$ --- (конечного) алфавита входных данных,
            \item рабочего алфавита $\Gamma$ --- (конечного) алфавита, над которым мы работаем, что $\Gamma \supseteq \Sigma \sqcup \{\spacesymbol\}$,
            \item конечного множества (внутренних) состояний $Q$,
            \item начального состояния $q_0 \in Q$,
            \item функции переходов $\delta: Q \times \Gamma \to Q \times \Gamma \times \{-1; +1\}$
            \item и дополнительных объектов и условий в зависимости от предназначения машины.
        \end{itemize}
        Входными данными программы является конечная строка $s_1 \dots s_l$, которая превращается в запись $\{a_i\}_{i \in \ZZ}$ на ленте по правилу
        \[
            a_i
            = \begin{cases}
                s_{i+1}& \text{ если } 0 \leqslant i \leqslant l-1,\\
                \spacesymbol& \text{ иначе.}
            \end{cases}
        \] 
        Состояние каждого момент вычисления --- это совокупность
        \begin{itemize}
            \item состояния ленты $\{a_i\}_{i \in \ZZ}$, где $a_i \in \Sigma$ и все $a_i$ кроме конечного числа элементов являются пробелом \spacesymbol,
            \item положения головки $n \in \ZZ$ на ленте и
            \item состояния головки $q \in Q$.
        \end{itemize}
        Состояние начального момента вычислений образуется из
        \begin{itemize}
            \item состояния ленты, полученного из входных данных,
            \item положения головки по умолчанию $n = 0$
            \item начального состояния головки $q_0$.
        \end{itemize}
        Каждым шагом состояние $(\{a_i\}_{i \in \ZZ}, n, q)$ заменяется на состояние $(\{a'_i\}_{i \in \ZZ}, n', q')$, где $a'_i = a_i$ для всех $i \in \ZZ \setminus \{n\}$ и
        \[
            (q', a'_n, n'-n) := \delta(q, a_n).
        \]

        Далее есть два вида предназначений машины:
        \begin{enumerate}
            \item \textbf{Распознование свойства.} В этом случае мы хотим уметь распознавать разные конечные строки, т.е. чтобы машина отвечала ``да'' или ``нет'' на вопрос ``Лежит ли эта строка в заданном семействе?''. В таком случае у машины выделяются \emph{принимающее состояние} $q_{acc} \in Q$ и \emph{отвергающее состояние} $q_{rej} \in Q$, и когда машина переходит в одно из этих двух состояний, вычисления прекращаются. В таком случае $\delta(q, a)$ должно быть не определено в случае $q \in \{q_{acc}; q_{rej}\}$.
            \item \textbf{Вычисление функции.} В этом случае мы хотим вычислять значение некоторой функции $M: \Sigma^* \to \Sigma^*$, т.е. чтобы машаина после некоторого количества действий говорила ``Готово.'' и оставляла на ленте конечное слово в том же формате, в котором производится ввод. В таком случае у машины выделяется \emph{состояние останова} $q_{halt} \in Q$, и когда машина переходит в это состояние, вычисления прекращаются, а на ленте должно остаться слово в правильном формате. В таком случае $\delta(q, a)$ должно быть не определено в случае $q = q_{halt}$.
        \end{enumerate}
    \end{definition}

    \begin{remark*}
        Фактически множество результатов работы машины состоит из переходов в одно из терминальных состояний ($q_{acc}$, $q_{rej}$ или $q_{halt}$) и попадание в ``вечный цикл''.
    \end{remark*}

    \begin{theorem}
        В определении машина Тьюринга множество возможных смещений головки $\{+1; -1\}$ можно сменить на некоторое $S \subseteq \ZZ$.
        \begin{enumerate}
            \item Тогда если $S$ конечно и всякое целое число представляется в виде суммы хотя бы одного значения (возможно, с повторами) из $S$, то определение получается равносильным.
            \item То же самое верно для всякого $S$ (не обязательно конечного).
        \end{enumerate}
    \end{theorem}

    \begin{proof}
        \begin{enumerate}
            \item Действительно, пусть у нас имеется машина с множеством возможных сдвигов $S_1$, а у нас есть множество возможных сдвигов $S_2$, что всякое число из $S_1$ представляется в виде суммы некоторых (хотя бы одного и, возможно, с повторениями) членов из $S_2$. Тогда для всякой перехода между состояниями $q_1 \to q_2$ можно создать такие фальшсостояния, что смещение на значение из $S_1$ будет заменено на несколько смещений на значения из $S_2$ с тем же итогом. Таким образом мы можем всякую машину на $S_1$ поменять на машину на $S_2$ и большим числом состояний.
        
                Таким образом множества смещений $S_1$ и $S_2$ реализуют равносильные модели, если всякое значение из $S_1$ расскладывается в сумму значений $S_2$ и наоборот. При для $S_1 = \{+1; -1\}$ переход $S_2 \to S_1$ очевиден, а переход $S_1 \to S_2$ означает, что $1$ и $-1$ раскладываются в суммы некоторых чисел из $S_2$, что равносильно разложимости всякого целого.

            \item Несложно понять, что в каждой конкретной машине Тьюринга множество $Q \times \Sigma$ конечно, а значит $S$ можно заменить на конечное подмножества, что задача для данной машины не изменится.
        \end{enumerate}
    \end{proof}

    \begin{corollary}
        Вместо $\{+1; -1\}$ для удобства можно также подразумевать $\{+1; 0; -1\}$.
    \end{corollary}

    \begin{remark*}
        В данный момент мы будем рассматривать только задачу распознавания свойства.
    \end{remark*}

    \begin{definition}
        \emph{Язык машины} $M$ или \emph{язык, распознаваемый машиной $M$,} --- это множество $L(M) \subseteq \Sigma^*$ входных строк, которые машина принимает. Т.е. это множество всех конечных строк $w \in \Sigma^*$ таких, что машина $M$ на входе $w$ завершает работу и принимает данный вход.

        Язык, распознаваемый какой-нибудь машиной, называется \emph{рекурсивно-перечислимым}.

        Язык, распознаваемый какой-нибудь машиной, которая останавливается на любом входе, называется \emph{рекурсивным}.
    \end{definition}

    \begin{example}
        Пусть $\Sigma = \{a; b\}$, $L = \{a^nb ^n\}_{n \geqslant 0}$. Тогда $L$ распознаётся машиной Тьюринга (которая причём останавливается на всяком входе!).

        Действительно, давайте напишем машину, которая будить ездить из одного конца нашей строки в другую и стирать $a$ справа и $b$ слева, и, если получит пустую строку, примет вход, а если поймет, что в какой-то момент получается что-то неправильное, то отвергнет вход. Формально, возьмём $Q = \{q_0; q_1; q_2; q_3; q_{acc}; q_{rej}\}$ и $\Gamma = \{a; b; \spacesymbol\}$, а функцию перехода опишем следующей таблицей:
        \begin{table}[H]
            \centering
            \begin{tabular}{c||c|c|c}
                $Q\backslash\Gamma$& $a$& $b$& $\spacesymbol$\\
                \hline
                \hline
                $q_0$& $q_1$, \spacesymbol, $+1$& $q_{rej}$& $q_{acc}$\\
                \hline
                $q_1$& $q_1$, $a$, $+1$& $q_1$, $b$, $+1$& $q_2$, \spacesymbol, $-1$\\
                \hline
                $q_2$& $q_{rej}$& $q_3$, \spacesymbol, $-1$& $q_{rej}$\\
                \hline
                $q_3$& $q_3$, $a$, $-1$& $q_3$, $b$, $-1$& $q_0$, \spacesymbol, $+1$\\
            \end{tabular}
        \end{table}
        Т.е. во с помощью $q_0$ и $q_2$ мы стираем $a$ слева и $b$ справа соответственно, а с помощью $q_1$ и $q_2$ перемещаемя до конца вправо и влево соответственно.
    \end{example}

    \begin{theorem}
        Есть язык, нераспознаваемый никакой машиной Тьюринга.
    \end{theorem}

    \begin{proof}
        Несложно видеть, что для всякого конечного непустого алфавита $\Sigma$ количество $|\Sigma^*|$ конечных строк над $\Sigma$ счётно, а значит языков над $\Sigma$ континуум. При этом машин Тьюринга с входным алфавитом $\Sigma$ счётное число. Значит почти все языки не распознаются машинами Тьюринга.

        При этом есть довольно простые конкретные примеры нераспознаваемых языков.
    \end{proof}

    \begin{definition}
        \emph{Запись $\sigma(M)$ машины Тьюринга $M$} --- это конечной битовая строка, созданная по следующему правилу. Пусть у машины $M = (\Sigma, \Gamma, Q, q_0, \delta, q_{acc}, q_{rej})$
        \begin{itemize}
            \item $\Sigma = \{a_1; \dots; a_l\}$,
            \item $\Gamma = \Sigma \cup \{a_{l+1}; \dots; a_m\}$, где причём $a_m = \spacesymbol$,
            \item $Q = \{q_0; \dots; q_{n-1}\}$, где причём $q_{acc} = q_{n-2}$, $q_{rej} = q_{n-1}$.
        \end{itemize}
        Тогда запишем всё в унарной системе счисления, т.е. (всякий абстрактный) массив числовых данных будет храниться в виде последовательностей единиц, длины которых будут равняться соответствующим значениям массиве, разделённых нулями. Тогда машина $M$ будет записана строкой
        \[\sigma(M) := 1^l\, 0\, 1^m\, 0\, 1^n\, 0 \prod_{\delta(q_i, a_j) = q_{i'}, a_{j'}, d} 1^i\, 0\, 1^j\, 0\, 1^{i'}\, 0\, 1^{j'}\, 0\, 1^{d+1}\]
        (где умножение, безусловно, --- конкатенация, а $\prod$ --- конкатенация нескольких строк).
    \end{definition}

    \begin{definition}
        Языки $L_0$ и $L_1$ --- это
        \[
            L_0 := \{\sigma(M) \mid \sigma(M) \notin L(M)\}
            \qquad \text{ и } \qquad
            L_1 := \{\sigma(M) \mid \sigma(M) \in L(M)\}.
        \]
    \end{definition}

    \begin{theorem}\ 
        \begin{enumerate}
            \item $L_0$ не рекурсивно-перечислимый.
            \item $L_1$ рекурсивно-перечислимый.
            \item $L_1$ не рекурсивный.
        \end{enumerate}
    \end{theorem}

    \begin{proof}
        \begin{enumerate}
            \item Предположим противное, т.е. есть машина $M$, распознающая $L_0$. Тогда если $M$ принимает $\sigma(M)$, то $\sigma(M) \in L(M)$, но тогда $\sigma(M) \notin L$. Если же $M$ не принимает $\sigma(M)$, то $\sigma(M) \notin L(M)$, но тогда $\sigma(M) \in L$. Противоречие наподобие парадокса Рассела. Значит нет никакой машины, распознающей $L_0$.
            \item Неформально опишем машину, которая будет распознавать $L_1$. Идея машины заключается в том, что получая на вход $\sigma(M)$, после этого запсанного кода машины $M$ она запишет код начального состояния $q_0$ машины $M$, а затем код $\sigma(M)$ как входную строчку для $M$. После этого она начнёт моделировать работу машины $M$ на входе $\sigma(M)$. Состояние головки будет писаться перед клеткой, на которую головка смотрит. Если места слева будет не хватать, то вся запись будет просто сдвигаться вправо.
            \item Покажим, что всякая машина, распознающая $L_1$ зацикливается при некотором входе. Предположим противное, т.е. есть машина $\widetilde{M}$, которая распознаёт $L_1$ и всегда остансавливается. Тогда построим $\widehat{M}$ по алгоритму:
                \begin{itemize}
                    \item Проверить правда ли, что на было подано некоторое $\sigma(M)$. Если нет, то отвергнуть.
                    \item Работать как $\widetilde{M}$ на $\sigma(M)$. Если $\widetilde{M}$ принимает, то отвергнуть. Если отвергает --- принять.
                \end{itemize}
                Тогда $\widehat{M}$ распознаёт $L_0$ --- противоречие. Значит машины $\widetilde{M}$ не существует.
        \end{enumerate}
    \end{proof}
    
    \begin{theorem}
        Язык
        \[L_\varnothing := \{\sigma(M) \mid L(M) = \varnothing\}\]
        не рекурсивно-перечислимый.
    \end{theorem}

    \begin{proof}
        Предположим противное, т.е. есть машина $M_\varnothing$, которая распознаёт $L_\varnothing$. Тогда построим машину $M_0$ по следующему алгоритму.
        \begin{enumerate}
            \item Проверить правда ли, что на было подано некоторое $\sigma(M)$. Если нет, то отвергнуть.
            \item Построить $\sigma(M')$, где машина $M'$ работает по следующему алгоритму.
                \begin{itemize}
                    \item Стереть входную строку.
                    \item Написать $\sigma(M)$.
                    \item Запустить $M$.
                \end{itemize}
            \item Запустить $M_\varnothing$ на $\sigma(M')$.
        \end{enumerate}
        $M'$ принимает любую строку, если $M$ принимает $\sigma(M)$, отвергает любую строку, если $M$ отвергает $\sigma(M)$, и зацикливается, если $M$ зацикливается на $\sigma(M)$. Следовательно $M_\varnothing$ примет $\sigma(M')$ тогда и только тогда, когда $\sigma(M) \notin L(M)$. Таким образом $M_0$ распознаёт $L_0$.
    \end{proof}

    \begin{definition}
        Для всякого свойства $P$ языков можно определить язык
        \[L_P := \{\sigma(M) \mid \text{$L(M)$ обладает свойством $P$}\}.\]
        Можно считать, что свойство есть некоторое множество языков (т.е. подмножество $2^{\Sigma^*}$), а обладание свойством означает содержание в нём как в множестве.

        Свойство называется \emph{тривиальным}, если либо ни один рекурсивно-перечислимый язык, либо все рекурсивно-перечислимые языки обладают этим свойством.
    \end{definition}

    \begin{example}\ 
        \begin{enumerate}
            \item Если $P$ --- это ``непустота'', то
                \[L_P := \{\sigma(M) \mid L(M) \neq \varnothing\}.\]
                Такой язык рекурсивно-перечислим.
            \item
                \[L_P := \{\sigma(M) \mid \text{$M$ отвергает конечное число программ на C++}\}.\]
            \item
                \[L_P := \{\sigma(M) \mid L(M) = L_0\}.\]
                Как мы уже знаем $L_P = \varnothing$, т.е. данное свойство тривиально.
        \end{enumerate}
    \end{example}

    \begin{theorem}[Райса]
        Всякое нетривиальное свойство нерекурсивно.
    \end{theorem}

    \begin{proof}
        Пусть дано нетривиальное свойство $P \subseteq 2^{\Sigma^*}$ рекурсивно-перечислимых языков. Предположим противное: есть машина $M_P$ распознаёт $L_p$ (не зацикливается и принимает только язык $L_p$).

        Предположим, что $\varnothing \notin P$. Тогда есть машина $\widehat{M}$, что $L(\widehat{M}) \notin P$. Тогда построим машину Тьюринга $M_1$, принимающую в себя $\sigma(M)$ некоторой машины Тьюринга $M$, со следующим алгоритмом:
        \begin{enumerate}
            \item Построить машину Тьюринга $\widetilde{M}$ по следующему описанию.
                \begin{enumerate}
                    \item Сохранить вход $w$.
                    \item Запустить $M$ на $\sigma(M)$.
                    \item Если отвергнет, зациклиться. Если примет, запустить $\widehat{M}$ на $w$.
                \end{enumerate}
            \item Запустить $M_P$ на $\sigma(\widetilde{M})$.
        \end{enumerate}
        Заметим, что если $\sigma(M) \notin L(M)$, то машина $\widetilde{M}$ зацикливается на любом входе, т.е. $L(\widetilde{M}) = \varnothing$. Иначе $\widetilde{M}$ совпадает с $\widehat{M}$, т.е. $L(\widetilde{M}) = L(\widehat{M})$. Таким образом
        \[L(\widetilde{M}) \in P \quad \Longleftrightarrow \quad \sigma(M) \in L(M).\]
        Таким образом ответ $M_p$ на входе $\sigma(\widetilde{M})$ есть ответ на вопрос принадлежности $\sigma(M)$ множеству $L(M)$. Таким образом $M_1$ не зацикливается и распознаёт язык $L_1$, что противоречит ранее доказанным утверждениям.

        Теперь предположим $\varnothing \in P$. Тогда есть машина $\widehat{M}$, что $L(\widehat{M}) \notin P$. По аналогии можно построить машину, которая распознаёт $L_0$.
    \end{proof}

    \section{Формальные зыки и автоматы}

    \begin{definition}
        \emph{Алфавит} $\Sigma$ --- фиксированный (контекстом) набор элементов (\emph{символов}). Мы будем рассматривать только конечные алфавиты.
        
        \emph{Строка} --- (если не оговорено обратное, конечная) последовательность символов из алфавита. Строки обозначаются либо просто как переменные, т.е. $w$, либо в виде
        \[a_1 \dots a_n,\]
        где $a_i$ --- символы из алфавита $\Sigma$. Строка, где $n=0$, называется \emph{пустой строкой} и обозначается $\varepsilon$. Значение $n$ называется длиной строки $w$ и обозначается $|w|$. Количество вхождение некоторого символа $a$ (т.е. количество индексов $i$, что $a_i = a$) обозначается $|w|_a$. Множество всех строк обозначается $\Sigma^*$.
        
        \emph{Конкатенация} --- бинарная операция на строках, определяемая по правилу
        \[(a_1 \dots a_n, b_1 \dots b_m) \mapsto a_1 \dots a_n b_1 \dots b_m.\]
        Конкатенация строк $u$ и $v$ обозначается $uv$ или $u \cdot v$. Множество строк с операцией конкатенации и выделенной $\varepsilon$ образуют моноид.

        \emph{Обращение строки} --- унарная операция на строках, определяемая по правилу
        \[a_1 \dots a_n \mapsto a_n \dots a_1.\]
        Обращение строки $w$ обозначается $w^R$.

        \emph{Язык} --- множество строк, т.е. подмножество $\Sigma^*$.
    \end{definition}

    \begin{definition}
        \emph{Детерминированный конечный автомат} (также ``ДКА'' или ``DFA'') $A$ --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item начального состояния $q_0 \in Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times \Sigma \to Q$.
        \end{itemize}
        Входными данными является конечная строка $w = s_1 \dots s_n$. Состояние вычисления после $k$ шагов --- это некоторое состояние автомата $q_k \in Q$. Соответственно, начальное состояние вычисления (оно же состояние вычисления после $0$ шагов) --- начальное состояние автомата $q_0$. Каждым шагом состояние $q_k$ заменяется на $q_{k+1} := \delta(q_k, s_{k+1})$. Т.е. формально вычисление --- это последовательность состояний $(q_k)_{k=0}^n$, где
        \begin{itemize}
            \item $q_0$ --- начальное состояние автомата,
            \item $q_{k+1} := \delta(q_k, s_{k+1})$.
        \end{itemize}
        Состояние $q_n$ называется \emph{результатом вычисления}. Также говорят, что автомат принимает строку $w$, если $q_n \in F$, и отвергает в ином случае.

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.

        Также в качестве удобства обозначений определим функцию $\delta^*$ на $Q \times \Sigma^*$ как
        \[\delta^*(q, a_1 \dots a_n) := \delta^*(\dots \delta(q, a_1), \dots, a_n),\]
        т.е. $\delta^*$ задаётся рекурсивно как
        \[\delta^*(q, \varepsilon) = q, \qquad \delta^*(q, aw) = \delta^*(\delta(q, a), w).\]
        Иногда мы будем писать $\delta$, подразумевая $\delta^*$.
    \end{definition}

    \begin{remark*}
        Детерминированные конечные автоматы удобно изображать в виде ориентированного графа. Пусть $Q$ --- вершины графа, и из каждой вершины $q$ ведёт по $|\Sigma|$ рёбер: ребро из $q$ с меткой $s$ (для всякого $s \in \Sigma$) ведёт в $\delta(q, s)$. Также небольшой стрелочкой ведущей из ниоткуда в $q_0$ удобно помечать $q_0$ как начальную вершину, и удобно обвести каждую вершину из $F$, чтобы пометить её как принимающую. 
    \end{remark*}

    \begin{remark*}
        Несложно видеть, что
        \[L(A) = \{w \in \Sigma^* \mid \delta^*_A(q_{A, 0}, w) \in F_A\}.\]
        Это также значит, что $w \in L(A)$ тогда и только тогда, когда при проходе в графе $A$ по пути, соответствующему слову $w$, мы попадаем в принимающее состояние. Говоря иначе, есть некоторая последовательность состояний $q_0, \dots, q_n$, что
        \begin{itemize}
            \item $n = |w|$,
            \item $q_0 = q_{A, 0}$ --- начальное состояние автомата,
            \item $q_{k+1} = \delta_A(q_k, a_{k+1})$,
            \item $q_n \in F_A$.
        \end{itemize}
    \end{remark*}

    \begin{theorem}
        Язык $L := \{a^n b^n\}_{n \in \NN}$ нерегулярен.
    \end{theorem}

    \begin{proof}
        Предположим имеется ДКА $A$, что $L(A) = L$. Заметим, что тогда строка $a^{|Q|} b^{|Q|} \in L$. Пусть вычисление этой строки имеет вид $q_0 \dots q_{|Q|} \dots$ (понятно, что $q_{|Q|}$ --- состояние вычисления после последней буквы $a$). По принципу Дирихле есть из состояний $q_0$, \dots, $q_{|Q|}$ есть два совпадающих; пусть это будут $q_i$ и $q_j$ ($i < j$). Тогда покажем, что $a^{|Q| - (j-i)} b^{|Q|}$ тоже распознаётся (хотя не должна). Заметим, что процесс вычисления букв $a$ будет иметь вид
        \[q_0 \dots q_i = q_j \dots q_{|Q|}.\]
        Таким образом состояние после прочтения последней буквы $a$ будет тем же, а значит состояние после прочтения всей строки тоже будет тем же, а значит принимающим.
    \end{proof}

    \begin{definition}
        Недетерминированный конечный автомат (также ``НКА'' или ``NFA'') --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item множества начальных состояния $S \subseteq Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times \Sigma \to 2^Q$.
        \end{itemize}
        Входными данными является конечная строка $w = s_1 \dots s_n$. Состояние вычисления после $k$ шагов --- это некоторое множество состояний автомата $S_k \in Q$. Соответственно, начальное состояние вычисления (оно же состояние вычисления после $0$ шагов) --- множество начальных состояние автомата $S_0 = S$. Каждым шагом состояние $S_k$ заменяется на $S_{k+1} := \bigcup_{q \in S_k} \delta(q, s_{k+1})$. Т.е. формально вычисление --- это последовательность множеств состояний $(S_k)_{k=0}^n$, где
        \begin{itemize}
            \item $S_0 = S$ --- начальное состояние автомата,
            \item $S_{k+1} := \bigcup_{q \in S_k} \delta(q, s_{k+1})$.
        \end{itemize}
        Множество состояний $S_n$ называется \emph{результатом вычисления}. Также говорят, что автомат принимает строку $w$, если $S_n \cap F \neq \varnothing$, и отвергает в ином случае.

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.

        Также в качестве удобства обозначений определим функцию $\delta^*$ на $2^Q \times \Sigma^*$ рекурсивно как
        \[
            \delta^*(T, w) = \bigcup_{q \in T} \delta^*(q, w),
            \qquad
            \delta^*(\{q\}, \varepsilon) = \{q\},
            \qquad
            \delta^*(\{q\}, aw) = \delta^*(\delta(q, a), w).
        \]
        Иногда мы будем писать $\delta$, подразумевая $\delta^*$.
    \end{definition}

    \begin{remark*}
        Недетерминированные конечные автоматы удобно изображать в виде ориентированного графа. Пусть $Q$ --- вершины графа, и из каждой вершины $q$ ведёт некоторое количество рёбер: по ребру из $q$ с меткой $s$ (для всякого $s \in \Sigma$) ведёт в каждую вершину из $\delta(q, s)$. Также небольшими стрелочками ведущими из ниоткуда в каждую вершину из $S$ удобно помечать $S$ как множество начальных вершин, и удобно обвести каждую вершину из $F$, чтобы пометить её как принимающую. 
    \end{remark*}

    \begin{remark*}
        Несложно видеть, что $w \in L(A)$ тогда и только тогда, когда есть путь в графе $A$, соответствующий строке $w$, что конечное состояние является принимающим. Говоря иначе, есть некоторая последовательность состояний $q_0, \dots, q_n$, что
        \begin{itemize}
            \item $n = |w|$,
            \item $q_0 \in S_A$,
            \item $q_{k+1} \in \delta_A(q_k, a_{k+1})$,
            \item $q_n \in F_A$.
        \end{itemize}
        С другой стороны это также равносильно тому, что $\delta^*_A(S_A, w) \in F_A$.
    \end{remark*}

    \begin{theorem}
        У всякого недетерминированного автомата $A$ есть детерминированный автомат $A'$, что $L(A') = L(A)$.
    \end{theorem}

    \begin{proof}
        Пусть дано, что $A = (\Sigma, Q, S, \delta, F)$. Тогда определим
        \[A' = (\Sigma, 2^Q, S, \delta', \{T \subseteq Q \mid T \cap F \neq \varnothing\}),\]
        где $\delta'$ определяется по правилу
        \[\delta'(T, s) := \delta(T, s) = \bigcap_{q \in T} \delta(q, s).\]

        Проще говоря, $A'$ имитирует $A$, запоминая в каком множестве состояний мы находимся в каждый момент и эмулируя правильный переход к новому множеству состояний. Формально говоря, несложно показать по индукции по $|w|$, что множество состояний автомата $A$ после прочтения слова $w$ является состоянием автомата $A'$ после прочтения того же слова $w$.
    \end{proof}

    \begin{remark}
        Можно на языках ввести следующие операции.
        \begin{itemize}
            \item $K \cup L$, $K \cap L$, $K \triangle L$, $\overline{L}$ --- стандартные операции на множествах.
            \item Конкатенация. $KL = K \cdot L := \{uv \mid u \in K \wedge v \in L\}$.
            \item Конкатенация нескольких копий. $L^k := L \cdot \dots \cdot L$. $L^0 = \{\varepsilon\}$.
            \item Конкатенация любого конечного числа копий или звёздочка Клини. $L^* = \bigcup_{k=0}^\infty L^k$.
        \end{itemize}

        В таком случае $(2^{\Sigma^*}, {\cup}, {\cdot}, \varnothing, \{\varepsilon\})$ --- полукольцо.
    \end{remark}

    \subsection{Регулярные выражение и равносильность конечным автоматам}

    \begin{definition}
        Рекурсивно определим понятие \emph{регулярного выражения}.
        \begin{itemize}
            \item $\varnothing$ --- регулярное выражение.
            \item $a$, где $a \in \Sigma$, --- регулярное выражение.
            \item $(\varphi \psi)$, $(\varphi | \psi)$ и $\varphi^*$, где $\varphi$ и $\psi$ есть регулярные выражения, --- регулярные выражения.
        \end{itemize}
        Множество регулярных выражений над алфавитом $\Sigma$ обозначается $\RE(\Sigma)$.
        
        Теперь рекурсивно определим \emph{язык регулярного выражения}.
        \begin{itemize}
            \item $L(\varnothing) = \varnothing$.
            \item $L(a) = \{a\}$.
            \item $L(\varphi \psi) = L(\varphi) L(\psi)$.
            \item $L(\varphi | \psi) = L(\varphi) \cup L(\psi)$.
            \item $L(\varphi^*) = L(\varphi)^*$.
        \end{itemize}
    \end{definition}

    \begin{theorem}
        Язык распознаётся конечным автоматом тогда и только тогда, когда задаётся регулярным выражением.
    \end{theorem}

    \begin{definition}
        Недетерминированный конечный автомат с $\varepsilon$-переходами (также ``$\varepsilon$-НКА'' или ``$\varepsilon$-NFA'') --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item множества начальных состояния $S \subseteq Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \to 2^Q$.
        \end{itemize}
        \emph{$\varepsilon$-замыканием} состояния $q$ называется множество состояний
        \[E(q) := \{p \mid \exists k \in \NN\colon \exists q_0, \dots, q_k \in Q\colon q_0 = q \wedge q_k = p \wedge \forall i = 1, \dots, k\; q_i = \delta(q_{i-1}, \varepsilon)\}.\]
        Также по аналогии $\varepsilon$-замыканием множества состояния $T$ называется множество состояний
        \[E(T) := \bigcup_{q \in T} E(q),\]
        откуда, в частности, получается ``рекурсивное определение''
        \[E(T) := T \cup \bigcup_{q \in T} E(\delta(q, \varepsilon)).\]
        Входными данными является конечная строка $w = s_1 \dots s_n$. Состояние вычисления после $k$ шагов --- это некоторое множество состояний автомата $S_k \in Q$. Соответственно, начальное состояние вычисления (оно же состояние вычисления после $0$ шагов) --- множество начальных состояние автомата $S_0 = E(S)$. Каждым шагом состояние $S_k$ заменяется на $S_{k+1} := \bigcup_{q \in S_k} E(\delta(q, s_{k+1}))$. Т.е. формально вычисление --- это последовательность множеств состояний $(S_k)_{k=0}^n$, где
        \begin{itemize}
            \item $S_0 = E(S)$ --- начальное состояние автомата,
            \item $S_{k+1} := \bigcup_{q \in S_k} E(\delta(q, s_{k+1}))$.
        \end{itemize}
        Множество состояний $S_n$ называется \emph{результатом вычисления}. Также говорят, что автомат принимает строку $w$, если $S_n \cap F \neq \varnothing$, и отвергает в ином случае.

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.

        Также в качестве удобства обозначений определим функцию $\delta^*$ на $2^Q \times \Sigma^*$ рекурсивно как
        \[
            \delta^*(T, w) = \bigcup_{q \in T} \delta^*(q, w),
            \qquad
            \delta^*(\{q\}, \varepsilon) = E(\{q\}),
            \qquad
            \delta^*(\{q\}, aw) = \delta^*\left(\bigcup_{p \in E(q)} \delta(p, a), w\right).
        \]
        Иногда мы будем писать $\delta$, подразумевая $\delta^*$.
    \end{definition}

    \begin{remark*}
        Недетерминированные конечные автоматы с $\varepsilon$-переходами удобно изображать точно также как обычные НКА, но на стрелках (ориентированных рёбрах) переходов теперь можно писать и новодобавленный символ $\varepsilon$.
    \end{remark*}

    \begin{remark*}
        Несложно видеть, что $w \in L(A)$ тогда и только тогда, когда есть некоторое представление $w = s_1 \dots s_n$, где $s_i \in \Sigma \cup \{\varepsilon\}$, и некоторая последовательность состояний $q_0, \dots, q_n$, что
        \begin{itemize}
            \item $q_0 \in S_A$,
            \item $q_{k+1} \in \delta_A(q_k, s_{k+1})$,
            \item $q_n \in F_A$.
        \end{itemize}
        С другой стороны это также равносильно тому, что $\delta^*_A(S_A, w) \in F_A$.
    \end{remark*}

    \begin{lemma}
        Всякое регулярное выражение можно заменить на $\varepsilon$-НКА, порождающий тот же язык.
    \end{lemma}

    \begin{proof}
        Давайте построим для каждого регулярного выражения $\varepsilon$-НКА с ровно одним начальным состоянием и ровно одним принимающим состоянием. И будем мы это делать по рекурсивному построению регулярного выражения:
        \begin{itemize}
            \item Автомат для регулярного выражения $\varnothing$ будет состоять только из одного начального и одного принимающего состояний, не иметь других состояний и не иметь никаких переходов.
            \item Автомат для регулярного выражения $a$ ($a \in \Sigma$) будет состоять только из одного начального и одного принимающего состояний, не иметь других состояний и иметь единственный переход от начального состояния к принимающему по символу $a$.
            \item Автомат для регулярного выражения $\varphi \psi$ будет получаться проведением перехода по $\varepsilon$ от принимающего состояния $\varphi$ к начальному состоянию $\psi$. Соединённые состояния теряют свои роли (т.е. больше не являются принимающей и начальной соответственно).
            \item Автомат для регулярного выражения $\varphi | \psi$ будет получаться проведением переходов по $\varepsilon$ от начального состояния строимого автомата к начальным состояниям автоматов $\varphi$ и $\psi$ и переходов по $\varepsilon$ от принимающих состояний автоматов $\varphi$ и $\psi$ к принимающему состоянию строимого автомата. Начальные и принимающие состояния старых автоматов теряют свои роли.
            \item Автомат для регулярного выражения $\varphi*$ будет получаться проведением перехода по $\varepsilon$ от начального состояния строимого автомата к начальному состоянию автомата $\varphi$, перехода по $\varepsilon$ от принимающего состояния автомата $\varphi$ к начальному состоянию строимого автомата и перехода по $\varepsilon$ от начального состояния строимого автомата к принимающему состоянию строимого автомата. Начальные и принимающие состояния старого автомата теряют свои роли.
        \end{itemize}
        \todo[inline]{Картиночки.}
        Несложно видеть по индукции по построению выражения, что строимые автоматы, действительно, строят язык соответствующих регулярных выражений.
    \end{proof}

    \begin{lemma}
        Всякий $\varepsilon$-НКА можно заменить на НКА, порождающий тот же язык.
    \end{lemma}

    \begin{proof}
        Неформально говоря, мы хотим во всяком пути $s_1 \dots s_n$ произвести разбиение на несколько блоков вида $\varepsilon^k a$ (для некоторых $k \in \NN$ и $a \in \Sigma$) оканчивающееся на дополнительный блок вида $\varepsilon^k$ и заменить каждый (не дополнительный) блок на ровно один переход; дополнительный блок можно будет убрать при правильной замене множества принимающих состояний.

        Теперь формальное построение. Пусть дан $\varepsilon$-НКА $A = (\Sigma, Q, S, F, \delta)$. Будем строить НКА $A'$. $\Sigma$, $Q$ и $S$ оставим без изменений. Теперь определим новые $\delta'$ и $F'$. $\delta'$ определяется по правилу
        \[\delta'(q, a) := \bigcup_{p \in E(q)} \delta(p, a),\]
        а $F'$ определяется как
        \[F' := \{q \in Q \mid E(q) \cap F \neq \varnothing\}.\]
    \end{proof}

    \begin{definition}
        Недетерминированный конечный автомат с regex-переходами (также ``RE-НКА'' или ``RE-NFA'') --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item множества начальных состояния $S \subseteq Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times \RE(\Sigma) \to 2^Q$, что для всякого $q \in Q$ и всех $r \in RE(\Sigma)$ кроме, быть может, конечного множества $\delta(q, r) = \varnothing$.
        \end{itemize}
        Входными данными является конечная строка $w$. Входная строка принимается автоматом, если есть её разбиение на подстроки $w = u_1 \dots u_n$, последовательность регулярных выражений $r_1$, \dots, $r_n$ и последовательность состояний $q_0$, \dots, $q_n$, что
        \begin{itemize}
            \item $u_k \in L(r_k)$ для всех $k$,
            \item $q_0 \in S$,
            \item $q_{k+1} \in \delta(q_k, r_{k+1})$,
            \item $q_n \in F$.
        \end{itemize}

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.
    \end{definition}

    \begin{remark*}
        Недетерминированные конечные автоматы с $\varepsilon$-переходами удобно изображать точно также как обычные НКА, но на стрелках (ориентированных рёбрах) переходов теперь можно писать не символы из $\Sigma$, а регулярные выражения из $\RE(\Sigma)$. Также по аналогии можно описать про существование пути в графе, но проще будет это вывести напрямик из уже данного определения.
    \end{remark*}

    \begin{remark*}
        В этом случае также можно написать рекурсивную формулу $\delta^*$ (и через неё определить принимаемые слова). Но в этот раз она будет совсем муторной и бесполезной.
    \end{remark*}

    \begin{lemma}
        Всякий RE-НКА можно заменить на регулярное выражение, порождающее тот же язык.
    \end{lemma}

    \begin{proof}
        Заметим, что регулярное выражение для пустой строки есть $\varnothing^*$. Таким образом WLOG рассматриваемый RE-НКА автомат содержит одно начальное и одно принимающее состояние; так как иначе можно создать новые начальное и принимающее состояния, провести $\varepsilon$-переходы из нового начального в старые начальные состояния и из старых принимающих в новое принимающее и забыть роли старых начальных и принимающих состояний.

        Будем уменьшать когда можно количество рёбер, а затем когда можно количество вершин. Рёбра будем склеивать кратные, т.е. если есть две вершины $p$ и $q$ два перехода из $p$ в $q$ по регулярным выражениям $r_1$ и $r_2$, то заменим на один переход из $p$ в $q$ по регулярному выражению $r_1 | r_2$. Очевидно, что язык автомата не меняется. Таким образом кратных рёбер у нас исчезают.

        Теперь пусть имеется состояние $q$ отличное от начального и принимающего. Попытаемся удалить $q$. Для всяких вершин $p_1$ и $p_2$ рассмотрим регулярные выражения $r_1$, $r_2$ и $r$, соответствующие переходам из $p_1$ в $q$, из $q$ в $r_2$ и из $q$ в $q$ соответственно, и заменим эти переходы (они будут удалены с удалением $q$) на перход из $p_1$ в $p_2$ по регулярному выражению $r_1 r* r_2$. Несложно проверить, что это тоже не изменит язык автомата.

        Таким образом у нас останутся только два состояния и не более двух переходов между ними. Пусть регулярное выражение перехода от начального состояния к принимающему --- $r$, а от принимающего к начальному --- $s$. Следовательно, язык автомата порождается регулярным выражением $r(sr)^*$.
    \end{proof}

    \subsection{Разные действия над автоматами}

    \begin{definition}
        Пусть даны ДКА $A = (\Sigma, P, p_0, \eta, E)$ и $B = (\Sigma, Q, q_0, \delta, F)$. \emph{Прямым произведением автоматов} $A$ и $B$ есть автомат $A \times B := C = (\Sigma, P \times Q, (p_0, q_0), \theta, E \times F)$, где
        \[\theta((p, q), a) := (\eta(p, a), \delta(q, a)).\]
        В таком случае $L(A \times B) = L(A) \cap L(B)$.

        Также можно построить автомат $C = (\Sigma, P \times Q, (p_0, q_0), \theta, E \times Q \cup P \times F)$, где
        \[\theta((p, q), a) := (\eta(p, a), \delta(q, a)).\]
        В таком случае $L(C) = L(A) \cup L(B)$.

        Также можно построить автомат $C = (\Sigma, P, p_0, \eta, P \setminus E)$. В таком случае $L(C) = \Sigma^* \setminus L(A)$.

        Также можно построить автомат $C = (\Sigma, P^P, f_\varepsilon = \Id, \widehat{\varepsilon}, \{f \in P^P \mid f^2(q_0) \in F\})$, где $P^P$ --- множество функций $P \to P$, $f_w: P \to P$ --- функция, переводящее всякое состояние $p$ в состояние, которое получается из $p$ прохождением по слову $w$, а
        \[\widehat{\delta}(f, a) := f_a \circ f.\]
        В таком случае $L(C) = \sqrt{L(A)} := \{w \in \Sigma^* \mid ww \in L(A)\}$.
    \end{definition}

    \begin{lemma}[о накачке, Рабин, Скотт]
        Пусть $L \subseteq \Sigma^*$ регулярен. Тогда есть константа $p \geqslant 1$, что для всякого слова $w$ длины хотя бы $p$ существует разбиение $w = xyz$, где $y \neq \varepsilon$ и $|xy| \leqslant p$, что для всех $l \geqslant 0$
        \[x y^l z \in L.\]
    \end{lemma}

    \begin{example}
        Язык $L = \{(ab)^n a^n\}_{n \in \NN}$ не регулярен, но удовлетворяет лемме о накачке.
    \end{example}

    % \section{Сложность вычислений}
    % \section{Теория информация}
\end{document}