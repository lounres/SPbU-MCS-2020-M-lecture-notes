\documentclass[12pt,a4paper]{article}
\usepackage{../.tex/mcs-notes}
\usepackage{todonotes}
% \usepackage{multicol}
\usepackage{float}

\settitle
{Теоретическая информатика.}
{\href{https://users.math-cs.spbu.ru/~okhotin/}{А.С. Охотин},
Э.А. Гирш и
Д.О. Соколов}
{\%D0\%A2\%D0\%98/MA.pdf}
\date{}

% \DeclareMathOperator{\Quot}{Quot}
% \DeclareMathOperator*{\osc}{osc}
% \DeclareMathOperator{\sign}{sign}
% \DeclareMathOperator{\const}{const}
% \DeclareMathOperator{\grad}{grad}
% \newcommand{\eqdef}{\mathbin{\stackrel{\mathrm{def}}{=}}}
% \newcommand{\True}{\mathrm{True}}
% \newcommand{\False}{\mathrm{False}}
\newcommand{\Id}{\mathrm{Id}}
% \renewcommand{\Re}{\mathrm{Re}}
% \renewcommand{\Im}{\mathrm{Im}}
\newcommand{\spacesymbol}{\ensuremath{\text{\textvisiblespace}}}
\newcommand{\RE}{\mathrm{RE}}

\begin{document}
    \maketitle

    \listoftodos[TODOs]

    \tableofcontents

    \vspace{2em}
    Литература:
    \begin{itemize}
        \item \dots
    \end{itemize}

    Страницы курса:
    \begin{itemize}
        \item \href{https://users.math-cs.spbu.ru/~okhotin/teaching/tcs_fl_2021/}{Часть курса}, прочитанная А.С. Охотиным.
    \end{itemize}
    
    \section{Вычислимость}

    \begin{definition}
        \emph{Машина Тьюринга} --- это реализация понятия вычисления. Она заключается в том, что имеется бесконечная в обе стороны клетчатая лента с записанным на ней конечным словом (по букве на клетку) --- входные данные вычисления --- и головка --- вычисляющий аппарат, которая в каждый момент времени смотрит на какую-то клетку ленты и имеет в себе некоторое внутреннее состояние вычислений. Каждым своим действием она читает символ в клетке, на которую смотрит, и в зависимости от прочитанного символа и внутреннего состояния в данный момент она пишет в клетку, на которую смотрит новый символ, стирая старый, переходит на новую клетку и меняет внутренне состояние.

        Формально машина Тьюринга $M$ --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$ --- (конечного) алфавита входных данных,
            \item рабочего алфавита $\Gamma$ --- (конечного) алфавита, над которым мы работаем, что $\Gamma \supseteq \Sigma \sqcup \{\spacesymbol\}$,
            \item конечного множества (внутренних) состояний $Q$,
            \item начального состояния $q_0 \in Q$,
            \item функции переходов $\delta: Q \times \Gamma \to Q \times \Gamma \times \{-1; +1\}$
            \item и дополнительных объектов и условий в зависимости от предназначения машины.
        \end{itemize}
        Входными данными программы является конечная строка $s_1 \dots s_l$, которая превращается в запись $\{a_i\}_{i \in \ZZ}$ на ленте по правилу
        \[
            a_i
            = \begin{cases}
                s_{i+1}& \text{ если } 0 \leqslant i \leqslant l-1,\\
                \spacesymbol& \text{ иначе.}
            \end{cases}
        \] 
        Состояние каждого момент вычисления --- это совокупность
        \begin{itemize}
            \item состояния ленты $\{a_i\}_{i \in \ZZ}$, где $a_i \in \Sigma$ и все $a_i$ кроме конечного числа элементов являются пробелом \spacesymbol,
            \item положения головки $n \in \ZZ$ на ленте и
            \item состояния головки $q \in Q$.
        \end{itemize}
        Состояние начального момента вычислений образуется из
        \begin{itemize}
            \item состояния ленты, полученного из входных данных,
            \item положения головки по умолчанию $n = 0$
            \item начального состояния головки $q_0$.
        \end{itemize}
        Каждым шагом состояние $(\{a_i\}_{i \in \ZZ}, n, q)$ заменяется на состояние $(\{a'_i\}_{i \in \ZZ}, n', q')$, где $a'_i = a_i$ для всех $i \in \ZZ \setminus \{n\}$ и
        \[
            (q', a'_n, n'-n) := \delta(q, a_n).
        \]

        Далее есть два вида предназначений машины:
        \begin{enumerate}
            \item \textbf{Распознование свойства.} В этом случае мы хотим уметь распознавать разные конечные строки, т.е. чтобы машина отвечала ``да'' или ``нет'' на вопрос ``Лежит ли эта строка в заданном семействе?''. В таком случае у машины выделяются \emph{принимающее состояние} $q_{acc} \in Q$ и \emph{отвергающее состояние} $q_{rej} \in Q$, и когда машина переходит в одно из этих двух состояний, вычисления прекращаются. В таком случае $\delta(q, a)$ должно быть не определено в случае $q \in \{q_{acc}; q_{rej}\}$.
            \item \textbf{Вычисление функции.} В этом случае мы хотим вычислять значение некоторой функции $M: \Sigma^* \to \Sigma^*$, т.е. чтобы машаина после некоторого количества действий говорила ``Готово.'' и оставляла на ленте конечное слово в том же формате, в котором производится ввод. В таком случае у машины выделяется \emph{состояние останова} $q_{halt} \in Q$, и когда машина переходит в это состояние, вычисления прекращаются, а на ленте должно остаться слово в правильном формате. В таком случае $\delta(q, a)$ должно быть не определено в случае $q = q_{halt}$.
        \end{enumerate}
    \end{definition}

    \begin{remark*}
        Фактически множество результатов работы машины состоит из переходов в одно из терминальных состояний ($q_{acc}$, $q_{rej}$ или $q_{halt}$) и попадание в ``вечный цикл''.
    \end{remark*}

    \begin{theorem}
        В определении машина Тьюринга множество возможных смещений головки $\{+1; -1\}$ можно сменить на некоторое $S \subseteq \ZZ$.
        \begin{enumerate}
            \item Тогда если $S$ конечно и всякое целое число представляется в виде суммы хотя бы одного значения (возможно, с повторами) из $S$, то определение получается равносильным.
            \item То же самое верно для всякого $S$ (не обязательно конечного).
        \end{enumerate}
    \end{theorem}

    \begin{proof}
        \begin{enumerate}
            \item Действительно, пусть у нас имеется машина с множеством возможных сдвигов $S_1$, а у нас есть множество возможных сдвигов $S_2$, что всякое число из $S_1$ представляется в виде суммы некоторых (хотя бы одного и, возможно, с повторениями) членов из $S_2$. Тогда для всякой перехода между состояниями $q_1 \to q_2$ можно создать такие фальшсостояния, что смещение на значение из $S_1$ будет заменено на несколько смещений на значения из $S_2$ с тем же итогом. Таким образом мы можем всякую машину на $S_1$ поменять на машину на $S_2$ и большим числом состояний.
        
                Таким образом множества смещений $S_1$ и $S_2$ реализуют равносильные модели, если всякое значение из $S_1$ расскладывается в сумму значений $S_2$ и наоборот. При для $S_1 = \{+1; -1\}$ переход $S_2 \to S_1$ очевиден, а переход $S_1 \to S_2$ означает, что $1$ и $-1$ раскладываются в суммы некоторых чисел из $S_2$, что равносильно разложимости всякого целого.

            \item Несложно понять, что в каждой конкретной машине Тьюринга множество $Q \times \Sigma$ конечно, а значит $S$ можно заменить на конечное подмножества, что задача для данной машины не изменится.
        \end{enumerate}
    \end{proof}

    \begin{corollary}
        Вместо $\{+1; -1\}$ для удобства можно также подразумевать $\{+1; 0; -1\}$.
    \end{corollary}

    \begin{remark*}
        В данный момент мы будем рассматривать только задачу распознавания свойства.
    \end{remark*}

    \begin{definition}
        \emph{Язык машины} $M$ или \emph{язык, распознаваемый машиной $M$,} --- это множество $L(M) \subseteq \Sigma^*$ входных строк, которые машина принимает. Т.е. это множество всех конечных строк $w \in \Sigma^*$ таких, что машина $M$ на входе $w$ завершает работу и принимает данный вход.

        Язык, распознаваемый какой-нибудь машиной, называется \emph{рекурсивно-перечислимым}.

        Язык, распознаваемый какой-нибудь машиной, которая останавливается на любом входе, называется \emph{рекурсивным}.
    \end{definition}

    \begin{example}
        Пусть $\Sigma = \{a; b\}$, $L = \{a^nb ^n\}_{n \geqslant 0}$. Тогда $L$ распознаётся машиной Тьюринга (которая причём останавливается на всяком входе!).

        Действительно, давайте напишем машину, которая будить ездить из одного конца нашей строки в другую и стирать $a$ справа и $b$ слева, и, если получит пустую строку, примет вход, а если поймет, что в какой-то момент получается что-то неправильное, то отвергнет вход. Формально, возьмём $Q = \{q_0; q_1; q_2; q_3; q_{acc}; q_{rej}\}$ и $\Gamma = \{a; b; \spacesymbol\}$, а функцию перехода опишем следующей таблицей:
        \begin{table}[H]
            \centering
            \begin{tabular}{c||c|c|c}
                $Q\backslash\Gamma$& $a$& $b$& $\spacesymbol$\\
                \hline
                \hline
                $q_0$& $q_1$, \spacesymbol, $+1$& $q_{rej}$& $q_{acc}$\\
                \hline
                $q_1$& $q_1$, $a$, $+1$& $q_1$, $b$, $+1$& $q_2$, \spacesymbol, $-1$\\
                \hline
                $q_2$& $q_{rej}$& $q_3$, \spacesymbol, $-1$& $q_{rej}$\\
                \hline
                $q_3$& $q_3$, $a$, $-1$& $q_3$, $b$, $-1$& $q_0$, \spacesymbol, $+1$\\
            \end{tabular}
        \end{table}
        Т.е. во с помощью $q_0$ и $q_2$ мы стираем $a$ слева и $b$ справа соответственно, а с помощью $q_1$ и $q_2$ перемещаемя до конца вправо и влево соответственно.
    \end{example}

    \begin{theorem}
        Есть язык, нераспознаваемый никакой машиной Тьюринга.
    \end{theorem}

    \begin{proof}
        Несложно видеть, что для всякого конечного непустого алфавита $\Sigma$ количество $|\Sigma^*|$ конечных строк над $\Sigma$ счётно, а значит языков над $\Sigma$ континуум. При этом машин Тьюринга с входным алфавитом $\Sigma$ счётное число. Значит почти все языки не распознаются машинами Тьюринга.

        При этом есть довольно простые конкретные примеры нераспознаваемых языков.
    \end{proof}

    \begin{definition}
        \emph{Запись $\sigma(M)$ машины Тьюринга $M$} --- это конечной битовая строка, созданная по следующему правилу. Пусть у машины $M = (\Sigma, \Gamma, Q, q_0, \delta, q_{acc}, q_{rej})$
        \begin{itemize}
            \item $\Sigma = \{a_1; \dots; a_l\}$,
            \item $\Gamma = \Sigma \cup \{a_{l+1}; \dots; a_m\}$, где причём $a_m = \spacesymbol$,
            \item $Q = \{q_0; \dots; q_{n-1}\}$, где причём $q_{acc} = q_{n-2}$, $q_{rej} = q_{n-1}$.
        \end{itemize}
        Тогда запишем всё в унарной системе счисления, т.е. (всякий абстрактный) массив числовых данных будет храниться в виде последовательностей единиц, длины которых будут равняться соответствующим значениям массиве, разделённых нулями. Тогда машина $M$ будет записана строкой
        \[\sigma(M) := 1^l\, 0\, 1^m\, 0\, 1^n\, 0 \prod_{\delta(q_i, a_j) = q_{i'}, a_{j'}, d} 1^i\, 0\, 1^j\, 0\, 1^{i'}\, 0\, 1^{j'}\, 0\, 1^{d+1}\]
        (где умножение, безусловно, --- конкатенация, а $\prod$ --- конкатенация нескольких строк).
    \end{definition}

    \begin{definition}
        Языки $L_0$ и $L_1$ --- это
        \[
            L_0 := \{\sigma(M) \mid \sigma(M) \notin L(M)\}
            \qquad \text{ и } \qquad
            L_1 := \{\sigma(M) \mid \sigma(M) \in L(M)\}.
        \]
    \end{definition}

    \begin{theorem}\ 
        \begin{enumerate}
            \item $L_0$ не рекурсивно-перечислимый.
            \item $L_1$ рекурсивно-перечислимый.
            \item $L_1$ не рекурсивный.
        \end{enumerate}
    \end{theorem}

    \begin{proof}
        \begin{enumerate}
            \item Предположим противное, т.е. есть машина $M$, распознающая $L_0$. Тогда если $M$ принимает $\sigma(M)$, то $\sigma(M) \in L(M)$, но тогда $\sigma(M) \notin L$. Если же $M$ не принимает $\sigma(M)$, то $\sigma(M) \notin L(M)$, но тогда $\sigma(M) \in L$. Противоречие наподобие парадокса Рассела. Значит нет никакой машины, распознающей $L_0$.
            \item Неформально опишем машину, которая будет распознавать $L_1$. Идея машины заключается в том, что получая на вход $\sigma(M)$, после этого запсанного кода машины $M$ она запишет код начального состояния $q_0$ машины $M$, а затем код $\sigma(M)$ как входную строчку для $M$. После этого она начнёт моделировать работу машины $M$ на входе $\sigma(M)$. Состояние головки будет писаться перед клеткой, на которую головка смотрит. Если места слева будет не хватать, то вся запись будет просто сдвигаться вправо.
            \item Покажим, что всякая машина, распознающая $L_1$ зацикливается при некотором входе. Предположим противное, т.е. есть машина $\widetilde{M}$, которая распознаёт $L_1$ и всегда остансавливается. Тогда построим $\widehat{M}$ по алгоритму:
                \begin{itemize}
                    \item Проверить правда ли, что на было подано некоторое $\sigma(M)$. Если нет, то отвергнуть.
                    \item Работать как $\widetilde{M}$ на $\sigma(M)$. Если $\widetilde{M}$ принимает, то отвергнуть. Если отвергает --- принять.
                \end{itemize}
                Тогда $\widehat{M}$ распознаёт $L_0$ --- противоречие. Значит машины $\widetilde{M}$ не существует.
        \end{enumerate}
    \end{proof}
    
    \begin{theorem}
        Язык
        \[L_\varnothing := \{\sigma(M) \mid L(M) = \varnothing\}\]
        не рекурсивно-перечислимый.
    \end{theorem}

    \begin{proof}
        Предположим противное, т.е. есть машина $M_\varnothing$, которая распознаёт $L_\varnothing$. Тогда построим машину $M_0$ по следующему алгоритму.
        \begin{enumerate}
            \item Проверить правда ли, что на было подано некоторое $\sigma(M)$. Если нет, то отвергнуть.
            \item Построить $\sigma(M')$, где машина $M'$ работает по следующему алгоритму.
                \begin{itemize}
                    \item Стереть входную строку.
                    \item Написать $\sigma(M)$.
                    \item Запустить $M$.
                \end{itemize}
            \item Запустить $M_\varnothing$ на $\sigma(M')$.
        \end{enumerate}
        $M'$ принимает любую строку, если $M$ принимает $\sigma(M)$, отвергает любую строку, если $M$ отвергает $\sigma(M)$, и зацикливается, если $M$ зацикливается на $\sigma(M)$. Следовательно $M_\varnothing$ примет $\sigma(M')$ тогда и только тогда, когда $\sigma(M) \notin L(M)$. Таким образом $M_0$ распознаёт $L_0$.
    \end{proof}

    \begin{definition}
        Для всякого свойства $P$ языков можно определить язык
        \[L_P := \{\sigma(M) \mid \text{$L(M)$ обладает свойством $P$}\}.\]
        Можно считать, что свойство есть некоторое множество языков (т.е. подмножество $2^{\Sigma^*}$), а обладание свойством означает содержание в нём как в множестве.

        Свойство называется \emph{тривиальным}, если либо ни один рекурсивно-перечислимый язык, либо все рекурсивно-перечислимые языки обладают этим свойством.
    \end{definition}

    \begin{example}\ 
        \begin{enumerate}
            \item Если $P$ --- это ``непустота'', то
                \[L_P := \{\sigma(M) \mid L(M) \neq \varnothing\}.\]
                Такой язык рекурсивно-перечислим.
            \item
                \[L_P := \{\sigma(M) \mid \text{$M$ отвергает конечное число программ на C++}\}.\]
            \item
                \[L_P := \{\sigma(M) \mid L(M) = L_0\}.\]
                Как мы уже знаем $L_P = \varnothing$, т.е. данное свойство тривиально.
        \end{enumerate}
    \end{example}

    \begin{theorem}[Райса]
        Всякое нетривиальное свойство нерекурсивно.
    \end{theorem}

    \begin{proof}
        Пусть дано нетривиальное свойство $P \subseteq 2^{\Sigma^*}$ рекурсивно-перечислимых языков. Предположим противное: есть машина $M_P$ распознаёт $L_p$ (не зацикливается и принимает только язык $L_p$).

        Предположим, что $\varnothing \notin P$. Тогда есть машина $\widehat{M}$, что $L(\widehat{M}) \notin P$. Тогда построим машину Тьюринга $M_1$, принимающую в себя $\sigma(M)$ некоторой машины Тьюринга $M$, со следующим алгоритмом:
        \begin{enumerate}
            \item Построить машину Тьюринга $\widetilde{M}$ по следующему описанию.
                \begin{enumerate}
                    \item Сохранить вход $w$.
                    \item Запустить $M$ на $\sigma(M)$.
                    \item Если отвергнет, зациклиться. Если примет, запустить $\widehat{M}$ на $w$.
                \end{enumerate}
            \item Запустить $M_P$ на $\sigma(\widetilde{M})$.
        \end{enumerate}
        Заметим, что если $\sigma(M) \notin L(M)$, то машина $\widetilde{M}$ зацикливается на любом входе, т.е. $L(\widetilde{M}) = \varnothing$. Иначе $\widetilde{M}$ совпадает с $\widehat{M}$, т.е. $L(\widetilde{M}) = L(\widehat{M})$. Таким образом
        \[L(\widetilde{M}) \in P \quad \Longleftrightarrow \quad \sigma(M) \in L(M).\]
        Таким образом ответ $M_p$ на входе $\sigma(\widetilde{M})$ есть ответ на вопрос принадлежности $\sigma(M)$ множеству $L(M)$. Таким образом $M_1$ не зацикливается и распознаёт язык $L_1$, что противоречит ранее доказанным утверждениям.

        Теперь предположим $\varnothing \in P$. Тогда есть машина $\widehat{M}$, что $L(\widehat{M}) \notin P$. По аналогии можно построить машину, которая распознаёт $L_0$.
    \end{proof}

    \section{Формальные зыки и автоматы}

    \begin{definition}
        \emph{Алфавит} $\Sigma$ --- фиксированный (контекстом) набор элементов (\emph{символов}). Мы будем рассматривать только конечные алфавиты.
        
        \emph{Строка} --- (если не оговорено обратное, конечная) последовательность символов из алфавита. Строки обозначаются либо просто как переменные, т.е. $w$, либо в виде
        \[a_1 \dots a_n,\]
        где $a_i$ --- символы из алфавита $\Sigma$. Строка, где $n=0$, называется \emph{пустой строкой} и обозначается $\varepsilon$. Значение $n$ называется длиной строки $w$ и обозначается $|w|$. Количество вхождение некоторого символа $a$ (т.е. количество индексов $i$, что $a_i = a$) обозначается $|w|_a$. Множество всех строк обозначается $\Sigma^*$.
        
        \emph{Конкатенация} --- бинарная операция на строках, определяемая по правилу
        \[(a_1 \dots a_n, b_1 \dots b_m) \mapsto a_1 \dots a_n b_1 \dots b_m.\]
        Конкатенация строк $u$ и $v$ обозначается $uv$ или $u \cdot v$. Множество строк с операцией конкатенации и выделенной $\varepsilon$ образуют моноид.

        \emph{Обращение строки} --- унарная операция на строках, определяемая по правилу
        \[a_1 \dots a_n \mapsto a_n \dots a_1.\]
        Обращение строки $w$ обозначается $w^R$.

        \emph{Язык} --- множество строк, т.е. подмножество $\Sigma^*$.
    \end{definition}

    \begin{definition}
        \emph{Детерминированный конечный автомат} (также ``ДКА'' или ``DFA'') $A$ --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item начального состояния $q_0 \in Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times \Sigma \to Q$.
        \end{itemize}
        Входными данными является конечная строка $w = s_1 \dots s_n$. Состояние вычисления после $k$ шагов --- это некоторое состояние автомата $q_k \in Q$. Соответственно, начальное состояние вычисления (оно же состояние вычисления после $0$ шагов) --- начальное состояние автомата $q_0$. Каждым шагом состояние $q_k$ заменяется на $q_{k+1} := \delta(q_k, s_{k+1})$. Т.е. формально вычисление --- это последовательность состояний $(q_k)_{k=0}^n$, где
        \begin{itemize}
            \item $q_0$ --- начальное состояние автомата,
            \item $q_{k+1} := \delta(q_k, s_{k+1})$.
        \end{itemize}
        Состояние $q_n$ называется \emph{результатом вычисления}. Также говорят, что автомат принимает строку $w$, если $q_n \in F$, и отвергает в ином случае.

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.

        Также в качестве удобства обозначений определим функцию $\delta^*$ на $Q \times \Sigma^*$ как
        \[\delta^*(q, a_1 \dots a_n) := \delta^*(\dots \delta(q, a_1), \dots, a_n),\]
        т.е. $\delta^*$ задаётся рекурсивно как
        \[\delta^*(q, \varepsilon) = q, \qquad \delta^*(q, aw) = \delta^*(\delta(q, a), w).\]
        Иногда мы будем писать $\delta$, подразумевая $\delta^*$.
    \end{definition}

    \begin{remark*}
        Детерминированные конечные автоматы удобно изображать в виде ориентированного графа. Пусть $Q$ --- вершины графа, и из каждой вершины $q$ ведёт по $|\Sigma|$ рёбер: ребро из $q$ с меткой $s$ (для всякого $s \in \Sigma$) ведёт в $\delta(q, s)$. Также небольшой стрелочкой ведущей из ниоткуда в $q_0$ удобно помечать $q_0$ как начальную вершину, и удобно обвести каждую вершину из $F$, чтобы пометить её как принимающую. 
    \end{remark*}

    \begin{remark*}
        Несложно видеть, что
        \[L(A) = \{w \in \Sigma^* \mid \delta^*_A(q_{A, 0}, w) \in F_A\}.\]
        Это также значит, что $w \in L(A)$ тогда и только тогда, когда при проходе в графе $A$ по пути, соответствующему слову $w$, мы попадаем в принимающее состояние. Говоря иначе, есть некоторая последовательность состояний $q_0, \dots, q_n$, что
        \begin{itemize}
            \item $n = |w|$,
            \item $q_0 = q_{A, 0}$ --- начальное состояние автомата,
            \item $q_{k+1} = \delta_A(q_k, a_{k+1})$,
            \item $q_n \in F_A$.
        \end{itemize}
    \end{remark*}

    \begin{theorem}
        Язык $L := \{a^n b^n\}_{n \in \NN}$ нерегулярен.
    \end{theorem}

    \begin{proof}
        Предположим имеется ДКА $A$, что $L(A) = L$. Заметим, что тогда строка $a^{|Q|} b^{|Q|} \in L$. Пусть вычисление этой строки имеет вид $q_0 \dots q_{|Q|} \dots$ (понятно, что $q_{|Q|}$ --- состояние вычисления после последней буквы $a$). По принципу Дирихле есть из состояний $q_0$, \dots, $q_{|Q|}$ есть два совпадающих; пусть это будут $q_i$ и $q_j$ ($i < j$). Тогда покажем, что $a^{|Q| - (j-i)} b^{|Q|}$ тоже распознаётся (хотя не должна). Заметим, что процесс вычисления букв $a$ будет иметь вид
        \[q_0 \dots q_i = q_j \dots q_{|Q|}.\]
        Таким образом состояние после прочтения последней буквы $a$ будет тем же, а значит состояние после прочтения всей строки тоже будет тем же, а значит принимающим.
    \end{proof}

    \begin{definition}
        Недетерминированный конечный автомат (также ``НКА'' или ``NFA'') --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item множества начальных состояния $S \subseteq Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times \Sigma \to 2^Q$.
        \end{itemize}
        Входными данными является конечная строка $w = s_1 \dots s_n$. Состояние вычисления после $k$ шагов --- это некоторое множество состояний автомата $S_k \in Q$. Соответственно, начальное состояние вычисления (оно же состояние вычисления после $0$ шагов) --- множество начальных состояние автомата $S_0 = S$. Каждым шагом состояние $S_k$ заменяется на $S_{k+1} := \bigcup_{q \in S_k} \delta(q, s_{k+1})$. Т.е. формально вычисление --- это последовательность множеств состояний $(S_k)_{k=0}^n$, где
        \begin{itemize}
            \item $S_0 = S$ --- начальное состояние автомата,
            \item $S_{k+1} := \bigcup_{q \in S_k} \delta(q, s_{k+1})$.
        \end{itemize}
        Множество состояний $S_n$ называется \emph{результатом вычисления}. Также говорят, что автомат принимает строку $w$, если $S_n \cap F \neq \varnothing$, и отвергает в ином случае.

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.

        Также в качестве удобства обозначений определим функцию $\delta^*$ на $2^Q \times \Sigma^*$ рекурсивно как
        \[
            \delta^*(T, w) = \bigcup_{q \in T} \delta^*(q, w),
            \qquad
            \delta^*(\{q\}, \varepsilon) = \{q\},
            \qquad
            \delta^*(\{q\}, aw) = \delta^*(\delta(q, a), w).
        \]
        Иногда мы будем писать $\delta$, подразумевая $\delta^*$.
    \end{definition}

    \begin{remark*}
        Недетерминированные конечные автоматы удобно изображать в виде ориентированного графа. Пусть $Q$ --- вершины графа, и из каждой вершины $q$ ведёт некоторое количество рёбер: по ребру из $q$ с меткой $s$ (для всякого $s \in \Sigma$) ведёт в каждую вершину из $\delta(q, s)$. Также небольшими стрелочками ведущими из ниоткуда в каждую вершину из $S$ удобно помечать $S$ как множество начальных вершин, и удобно обвести каждую вершину из $F$, чтобы пометить её как принимающую. 
    \end{remark*}

    \begin{remark*}
        Несложно видеть, что $w \in L(A)$ тогда и только тогда, когда есть путь в графе $A$, соответствующий строке $w$, что конечное состояние является принимающим. Говоря иначе, есть некоторая последовательность состояний $q_0, \dots, q_n$, что
        \begin{itemize}
            \item $n = |w|$,
            \item $q_0 \in S_A$,
            \item $q_{k+1} \in \delta_A(q_k, a_{k+1})$,
            \item $q_n \in F_A$.
        \end{itemize}
        С другой стороны это также равносильно тому, что $\delta^*_A(S_A, w) \in F_A$.
    \end{remark*}

    \begin{theorem}
        У всякого недетерминированного автомата $A$ есть детерминированный автомат $A'$, что $L(A') = L(A)$.
    \end{theorem}

    \begin{proof}
        Пусть дано, что $A = (\Sigma, Q, S, \delta, F)$. Тогда определим
        \[A' = (\Sigma, 2^Q, S, \delta', \{T \subseteq Q \mid T \cap F \neq \varnothing\}),\]
        где $\delta'$ определяется по правилу
        \[\delta'(T, s) := \delta(T, s) = \bigcap_{q \in T} \delta(q, s).\]

        Проще говоря, $A'$ имитирует $A$, запоминая в каком множестве состояний мы находимся в каждый момент и эмулируя правильный переход к новому множеству состояний. Формально говоря, несложно показать по индукции по $|w|$, что множество состояний автомата $A$ после прочтения слова $w$ является состоянием автомата $A'$ после прочтения того же слова $w$.
    \end{proof}

    \begin{remark}
        Можно на языках ввести следующие операции.
        \begin{itemize}
            \item $K \cup L$, $K \cap L$, $K \triangle L$, $\overline{L}$ --- стандартные операции на множествах.
            \item Конкатенация. $KL = K \cdot L := \{uv \mid u \in K \wedge v \in L\}$.
            \item Конкатенация нескольких копий. $L^k := L \cdot \dots \cdot L$. $L^0 = \{\varepsilon\}$.
            \item Конкатенация любого конечного числа копий или звёздочка Клини. $L^* = \bigcup_{k=0}^\infty L^k$.
        \end{itemize}

        В таком случае $(2^{\Sigma^*}, {\cup}, {\cdot}, \varnothing, \{\varepsilon\})$ --- полукольцо.
    \end{remark}

    \subsection{Регулярные выражение и равносильность конечным автоматам}

    \begin{definition}
        Рекурсивно определим понятие \emph{регулярного выражения}.
        \begin{itemize}
            \item $\varnothing$ --- регулярное выражение.
            \item $a$, где $a \in \Sigma$, --- регулярное выражение.
            \item $(\varphi \psi)$, $(\varphi | \psi)$ и $\varphi^*$, где $\varphi$ и $\psi$ есть регулярные выражения, --- регулярные выражения.
        \end{itemize}
        Множество регулярных выражений над алфавитом $\Sigma$ обозначается $\RE(\Sigma)$.
        
        Теперь рекурсивно определим \emph{язык регулярного выражения}.
        \begin{itemize}
            \item $L(\varnothing) = \varnothing$.
            \item $L(a) = \{a\}$.
            \item $L(\varphi \psi) = L(\varphi) L(\psi)$.
            \item $L(\varphi | \psi) = L(\varphi) \cup L(\psi)$.
            \item $L(\varphi^*) = L(\varphi)^*$.
        \end{itemize}
    \end{definition}

    \begin{theorem}
        Язык распознаётся конечным автоматом тогда и только тогда, когда задаётся регулярным выражением.
    \end{theorem}

    \begin{definition}
        Недетерминированный конечный автомат с $\varepsilon$-переходами (также ``$\varepsilon$-НКА'' или ``$\varepsilon$-NFA'') --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item множества начальных состояния $S \subseteq Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \to 2^Q$.
        \end{itemize}
        \emph{$\varepsilon$-замыканием} состояния $q$ называется множество состояний
        \[E(q) := \{p \mid \exists k \in \NN\colon \exists q_0, \dots, q_k \in Q\colon q_0 = q \wedge q_k = p \wedge \forall i = 1, \dots, k\; q_i = \delta(q_{i-1}, \varepsilon)\}.\]
        Также по аналогии $\varepsilon$-замыканием множества состояния $T$ называется множество состояний
        \[E(T) := \bigcup_{q \in T} E(q),\]
        откуда, в частности, получается ``рекурсивное определение''
        \[E(T) := T \cup \bigcup_{q \in T} E(\delta(q, \varepsilon)).\]
        Входными данными является конечная строка $w = s_1 \dots s_n$. Состояние вычисления после $k$ шагов --- это некоторое множество состояний автомата $S_k \in Q$. Соответственно, начальное состояние вычисления (оно же состояние вычисления после $0$ шагов) --- множество начальных состояние автомата $S_0 = E(S)$. Каждым шагом состояние $S_k$ заменяется на $S_{k+1} := \bigcup_{q \in S_k} E(\delta(q, s_{k+1}))$. Т.е. формально вычисление --- это последовательность множеств состояний $(S_k)_{k=0}^n$, где
        \begin{itemize}
            \item $S_0 = E(S)$ --- начальное состояние автомата,
            \item $S_{k+1} := \bigcup_{q \in S_k} E(\delta(q, s_{k+1}))$.
        \end{itemize}
        Множество состояний $S_n$ называется \emph{результатом вычисления}. Также говорят, что автомат принимает строку $w$, если $S_n \cap F \neq \varnothing$, и отвергает в ином случае.

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.

        Также в качестве удобства обозначений определим функцию $\delta^*$ на $2^Q \times \Sigma^*$ рекурсивно как
        \[
            \delta^*(T, w) = \bigcup_{q \in T} \delta^*(q, w),
            \qquad
            \delta^*(\{q\}, \varepsilon) = E(\{q\}),
            \qquad
            \delta^*(\{q\}, aw) = \delta^*\left(\bigcup_{p \in E(q)} \delta(p, a), w\right).
        \]
        Иногда мы будем писать $\delta$, подразумевая $\delta^*$.
    \end{definition}

    \begin{remark*}
        Недетерминированные конечные автоматы с $\varepsilon$-переходами удобно изображать точно также как обычные НКА, но на стрелках (ориентированных рёбрах) переходов теперь можно писать и новодобавленный символ $\varepsilon$.
    \end{remark*}

    \begin{remark*}
        Несложно видеть, что $w \in L(A)$ тогда и только тогда, когда есть некоторое представление $w = s_1 \dots s_n$, где $s_i \in \Sigma \cup \{\varepsilon\}$, и некоторая последовательность состояний $q_0, \dots, q_n$, что
        \begin{itemize}
            \item $q_0 \in S_A$,
            \item $q_{k+1} \in \delta_A(q_k, s_{k+1})$,
            \item $q_n \in F_A$.
        \end{itemize}
        С другой стороны это также равносильно тому, что $\delta^*_A(S_A, w) \in F_A$.
    \end{remark*}

    \begin{lemma}
        Всякое регулярное выражение можно заменить на $\varepsilon$-НКА, порождающий тот же язык.
    \end{lemma}

    \begin{proof}
        Давайте построим для каждого регулярного выражения $\varepsilon$-НКА с ровно одним начальным состоянием и ровно одним принимающим состоянием. И будем мы это делать по рекурсивному построению регулярного выражения:
        \begin{itemize}
            \item Автомат для регулярного выражения $\varnothing$ будет состоять только из одного начального и одного принимающего состояний, не иметь других состояний и не иметь никаких переходов.
            \item Автомат для регулярного выражения $a$ ($a \in \Sigma$) будет состоять только из одного начального и одного принимающего состояний, не иметь других состояний и иметь единственный переход от начального состояния к принимающему по символу $a$.
            \item Автомат для регулярного выражения $\varphi \psi$ будет получаться проведением перехода по $\varepsilon$ от принимающего состояния $\varphi$ к начальному состоянию $\psi$. Соединённые состояния теряют свои роли (т.е. больше не являются принимающей и начальной соответственно).
            \item Автомат для регулярного выражения $\varphi | \psi$ будет получаться проведением переходов по $\varepsilon$ от начального состояния строимого автомата к начальным состояниям автоматов $\varphi$ и $\psi$ и переходов по $\varepsilon$ от принимающих состояний автоматов $\varphi$ и $\psi$ к принимающему состоянию строимого автомата. Начальные и принимающие состояния старых автоматов теряют свои роли.
            \item Автомат для регулярного выражения $\varphi*$ будет получаться проведением перехода по $\varepsilon$ от начального состояния строимого автомата к начальному состоянию автомата $\varphi$, перехода по $\varepsilon$ от принимающего состояния автомата $\varphi$ к начальному состоянию строимого автомата и перехода по $\varepsilon$ от начального состояния строимого автомата к принимающему состоянию строимого автомата. Начальные и принимающие состояния старого автомата теряют свои роли.
        \end{itemize}
        \todo[inline]{Картиночки.}
        Несложно видеть по индукции по построению выражения, что строимые автоматы, действительно, строят язык соответствующих регулярных выражений.
    \end{proof}

    \begin{lemma}
        Всякий $\varepsilon$-НКА можно заменить на НКА, порождающий тот же язык.
    \end{lemma}

    \begin{proof}
        Неформально говоря, мы хотим во всяком пути $s_1 \dots s_n$ произвести разбиение на несколько блоков вида $\varepsilon^k a$ (для некоторых $k \in \NN$ и $a \in \Sigma$) оканчивающееся на дополнительный блок вида $\varepsilon^k$ и заменить каждый (не дополнительный) блок на ровно один переход; дополнительный блок можно будет убрать при правильной замене множества принимающих состояний.

        Теперь формальное построение. Пусть дан $\varepsilon$-НКА $A = (\Sigma, Q, S, F, \delta)$. Будем строить НКА $A'$. $\Sigma$, $Q$ и $S$ оставим без изменений. Теперь определим новые $\delta'$ и $F'$. $\delta'$ определяется по правилу
        \[\delta'(q, a) := \bigcup_{p \in E(q)} \delta(p, a),\]
        а $F'$ определяется как
        \[F' := \{q \in Q \mid E(q) \cap F \neq \varnothing\}.\]
    \end{proof}

    \begin{definition}
        Недетерминированный конечный автомат с regex-переходами (также ``RE-НКА'' или ``RE-NFA'') --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item множества начальных состояния $S \subseteq Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times \RE(\Sigma) \to 2^Q$, что для всякого $q \in Q$ и всех $r \in RE(\Sigma)$ кроме, быть может, конечного множества $\delta(q, r) = \varnothing$.
        \end{itemize}
        Входными данными является конечная строка $w$. Входная строка принимается автоматом, если есть её разбиение на подстроки $w = u_1 \dots u_n$, последовательность регулярных выражений $r_1$, \dots, $r_n$ и последовательность состояний $q_0$, \dots, $q_n$, что
        \begin{itemize}
            \item $u_k \in L(r_k)$ для всех $k$,
            \item $q_0 \in S$,
            \item $q_{k+1} \in \delta(q_k, r_{k+1})$,
            \item $q_n \in F$.
        \end{itemize}

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.
    \end{definition}

    \begin{remark*}
        Недетерминированные конечные автоматы с $\varepsilon$-переходами удобно изображать точно также как обычные НКА, но на стрелках (ориентированных рёбрах) переходов теперь можно писать не символы из $\Sigma$, а регулярные выражения из $\RE(\Sigma)$. Также по аналогии можно описать про существование пути в графе, но проще будет это вывести напрямик из уже данного определения.
    \end{remark*}

    \begin{remark*}
        В этом случае также можно написать рекурсивную формулу $\delta^*$ (и через неё определить принимаемые слова). Но в этот раз она будет совсем муторной и бесполезной.
    \end{remark*}

    \begin{lemma}
        Всякий RE-НКА можно заменить на регулярное выражение, порождающее тот же язык.
    \end{lemma}

    \begin{proof}
        Заметим, что регулярное выражение для пустой строки есть $\varnothing^*$. Таким образом WLOG рассматриваемый RE-НКА автомат содержит одно начальное и одно принимающее состояние; так как иначе можно создать новые начальное и принимающее состояния, провести $\varepsilon$-переходы из нового начального в старые начальные состояния и из старых принимающих в новое принимающее и забыть роли старых начальных и принимающих состояний.

        Будем уменьшать когда можно количество рёбер, а затем когда можно количество вершин. Рёбра будем склеивать кратные, т.е. если есть две вершины $p$ и $q$ два перехода из $p$ в $q$ по регулярным выражениям $r_1$ и $r_2$, то заменим на один переход из $p$ в $q$ по регулярному выражению $r_1 | r_2$. Очевидно, что язык автомата не меняется. Таким образом кратных рёбер у нас исчезают.

        Теперь пусть имеется состояние $q$ отличное от начального и принимающего. Попытаемся удалить $q$. Для всяких вершин $p_1$ и $p_2$ рассмотрим регулярные выражения $r_1$, $r_2$ и $r$, соответствующие переходам из $p_1$ в $q$, из $q$ в $r_2$ и из $q$ в $q$ соответственно, и заменим эти переходы (они будут удалены с удалением $q$) на перход из $p_1$ в $p_2$ по регулярному выражению $r_1 r* r_2$. Несложно проверить, что это тоже не изменит язык автомата.

        Таким образом у нас останутся только два состояния и не более двух переходов между ними. Пусть регулярное выражение перехода от начального состояния к принимающему --- $r$, а от принимающего к начальному --- $s$. Следовательно, язык автомата порождается регулярным выражением $r(sr)^*$.
    \end{proof}

    \subsection{Разные действия над автоматами}

    \begin{definition}
        Пусть даны ДКА $A = (\Sigma, P, p_0, \eta, E)$ и $B = (\Sigma, Q, q_0, \delta, F)$. \emph{Прямым произведением автоматов} $A$ и $B$ есть автомат $A \times B := C = (\Sigma, P \times Q, (p_0, q_0), \theta, E \times F)$, где
        \[\theta((p, q), a) := (\eta(p, a), \delta(q, a)).\]
        В таком случае $L(A \times B) = L(A) \cap L(B)$.

        Также можно построить автомат $C = (\Sigma, P \times Q, (p_0, q_0), \theta, E \times Q \cup P \times F)$, где
        \[\theta((p, q), a) := (\eta(p, a), \delta(q, a)).\]
        В таком случае $L(C) = L(A) \cup L(B)$.

        Также можно построить автомат $C = (\Sigma, P, p_0, \eta, P \setminus E)$. В таком случае $L(C) = \Sigma^* \setminus L(A)$.

        Также можно построить автомат $C = (\Sigma, P^P, f_\varepsilon = \Id, \widehat{\varepsilon}, \{f \in P^P \mid f^2(q_0) \in F\})$, где $P^P$ --- множество функций $P \to P$, $f_w: P \to P$ --- функция, переводящее всякое состояние $p$ в состояние, которое получается из $p$ прохождением по слову $w$, а
        \[\widehat{\delta}(f, a) := f_a \circ f.\]
        В таком случае $L(C) = \sqrt{L(A)} := \{w \in \Sigma^* \mid ww \in L(A)\}$.
    \end{definition}

    \begin{lemma}[о накачке, Рабин, Скотт]
        Пусть $L \subseteq \Sigma^*$ регулярен. Тогда есть константа $p \geqslant 1$, что для всякого слова $w$ длины хотя бы $p$ существует разбиение $w = xyz$, где $y \neq \varepsilon$ и $|xy| \leqslant p$, что для всех $l \geqslant 0$
        \[x y^l z \in L.\]
    \end{lemma}

    \begin{example}
        Язык $L = \{(ab)^n a^n\}_{n \in \NN}$ не регулярен, но удовлетворяет лемме о накачке.
    \end{example}

    \subsection{Минимальные ДКА}

    \begin{definition}
        Пусть дан ДКА $A$. \emph{Язык, принимаемый из состояния} $q$ --- язык
        \[L_A(q) := \{w \in \Sigma^* \mid \delta_A^*(q, w) \in F_A\}.\]
        Состояния, из которых принимаются эквивалентные состояния, называются \emph{равносильными}.
    \end{definition}

    \begin{lemma}
        Пусть в ДКА $A$ для двух различных вершин $q$ и $q' \neq q_0$ верно, что $L_A(q) = L_A(q')$. Рассмотрим автомат $A'$, полученный из автомата $A$ удалением вершины $q'$ и перенаправлением всех переходов, идущих в $q'$, на $q$.
        \begin{enumerate}
            \item $L_{A'}(p) = L_A(p)$ для всякой вершины $p \in Q \setminus \{q'\}$.
            \item $L(A') = L(A)$.
        \end{enumerate}
    \end{lemma}

    \begin{lemma}
        Пусть дан регулярный язык $L$ и строки $u, v \in \Sigma^*$, что существует строка $w \in \Sigma^*$, что одна из $uw$ и $vw$ лежит в $L$, а другая --- нет. Тогда для всякого ДКА $A$, реализующего $L$, верно, что
        \[\delta^*(q_0, u) \neq \delta^*(q_0, v).\]
    \end{lemma}

    \begin{lemma}
        Если ДКА $A$ минимален, то
        \begin{itemize}
            \item все состояния достижимы,
            \item из разных состояний принимаются разные языки.
        \end{itemize}
    \end{lemma}

    \begin{theorem}
        ДКА, реализующий язык $L$, без недостижимых состояний, где из разных состояний принимаются разные языки, единственен с точностью до изоморфизма (переименовывания состояний).
    \end{theorem}

    \begin{proof}
        Пусть $A$, $B$ --- два таких ДКА, порождающие язык $L$. Для каждого состояния $q \in Q_A$ выберем какую-нибудь строку $w_q$, что
        \[\delta_A^*(q_{A, 0}, w_q) = q.\]
        Тогда обозначим
        \[r_q := \delta_B^*(q_{B, 0}, w_q).\]

        Если для каких-то различных $p$ и $q$ верно, что $r_p = r_q$, то для всякой строки $w \in \Sigma^*$ верно, что
        \[w_p w \in L \quad \Longleftrightarrow \quad w_q w \in L.\]
        Отсюда следует, что $L_A(p) = L_A(q)$ --- противоречие с определением $A$. Значит все $r_q$ попарно различны. Следовательно $|Q_A| \leqslant |Q_B|$; аналогично наоборот. Значит отображение $\varphi: q \mapsto r_q$ задаёт биекцию.

        Если какая-то строка $w \in L_A(q)$, то $w_q w \in L(A) = L(B)$, значит $w \in L_B(\varphi(q))$. Таким образом $L_A(q) \subseteq L_B(\varphi(q))$; аналогично наоборот. Таким образом $L_A(q) = L_B(\varphi(q))$.

        Таким образом начальные и принимающие состояние автоматов соответствуют по $\varphi$, так как состояние $q$ начально тогда и только тогда, когда $L_A(q) = L(A)$, и принимающее тогда и только тогда, когда $\varepsilon \in L_A(q)$.

        Возьмём любое состояние $q \in Q_A$ и $a \in \Sigma$. Обозначим $p_A := \delta_A(q, a)$, $p_B := \delta_B(\varphi(q), a)$. Тогда если есть $w \in L_A(p_A) \bigtriangleup L_B(p_B)$, то $aw \in L_A(q) \bigtriangleup L_B(\varphi(q))$. Но $L_A(q) = L_B(\varphi(q))$, а значит
        \[\varphi(\delta_A(q, a)) = \delta_B(\varphi(q), a),\]
        т.е. $\delta_A$ и $\delta_B$ соответствуют друг другу по $\varphi$.

        Таким образом $\varphi$ --- изоморфизм автоматов $A$ и $B$.
    \end{proof}

    \begin{corollary}
        Любой автомат, реализующий $L$, является минимальным тогда и только тогда, когда не имеет недостижимых состояний, а из разных состояний принимаются разные языки.
    \end{corollary}

    \begin{corollary}
        Из любого автомата можно получить минимальный, убрав недостижимые состояния и склеив эквивалентные. 
    \end{corollary}

    \begin{corollary}
        У всех автоматов без недостижимых состояний множество (следовательно, и количество) языков, принимаемых из состояний одинаковое.
    \end{corollary}

    \begin{theorem}
        Есть алгоритм, минимизирующий ДКА.
    \end{theorem}

    \begin{proof}
        Уберём из автомата все недостижимые состояния. Язык не поменяется.

        В начале рассмотрим разбиение всех состояний $\Omega_0 := \{F; Q \setminus F\}$. Определим для всякого разбиения $\Omega$ множества $Q$ функцию $s_\Omega: Q \to \Omega$, которая сопоставляет всякому состоянию $q$, множество разбиения $\Omega$ в котором оно находится, и отношение $\sim_\Omega$ на $Q$ по правилу
        \[
            p \sim_\Omega q
            \quad \Longleftrightarrow \quad
            s_\Omega(p) = s_\Omega(q) \wedge \forall a \in \Sigma\; s_\Omega(\delta(p, a)) = s_\Omega(\delta(q, a)).
        \]
        Тогда построим последовательность $(\Omega_i)_{i=0}^\infty$, где $\Omega_0$ уже определено, а $\Omega_{i+1} = Q/{\sim}_{\Omega_i}$.

        Заметим следующее.
        \begin{itemize}
            \item $\Omega_{i+1}$ есть подразбиение $\Omega_i$.
            \item Всякие состояния, из которых принимаются одинаковые языки, лежат в одних и тех же множествах разбиения $\Sigma_0$. То же верно и для всякого $\Omega_i$, что можно доказать по индукции по $i$: действительно, если они не были разделены разбиением $\Omega_i$, то они эквивалентны по отношению $\sim_{\Omega_i}$, а значит не будут разделены разбиением $\Omega_{i+1}$.
            \item Разбиений $\Omega$ конечное множество. Значит с некоторого момента последовательность стабилизируется.
        \end{itemize}
        Таким образом в пределе имеется разбиение $\Omega$, для которого верно
        \[\Omega = Q/{\sim}_\Omega.\]

        Если есть какие-то два состояния $p$ и $q$, из которых принимаются разные языки, то есть слово $w \in L_A(p) \bigtriangleup L_A(q)$. Значит $\delta^*(p, w)$ и $\delta^*(q, w)$ разделены разбиением $\Omega_0$, а значит и $\Omega$. Но если бы $p$ и $q$ не были бы разделены разбиением $\Omega$, то и $\delta^*(p, w)$ и $\delta^*(q, w)$ не были бы. Значит $\Omega$ --- разбиение по принимаемым из состояний языкам.

        Построение последовательности $\Omega_i$ реализуется алгоритмически, а вместе с ней и проверка $\Omega_{i+1} = \Omega_i$. Значит можно построить разбиение $\Omega$ и склеить вершины по этому разбиению (рассмотреть автомат по модулю разбиения как отношения эквивалентности). Получим автомат, реализующий тот же язык, но без недостижимых состояний, где языки, принимаемые из состояний, попарно различны. Значит данный автомат минимален.
    \end{proof}

    \subsection{Двухсторонние автоматы}

    \begin{definition}
        \emph{Двухсторонний детерминированный конечный автомат} (также ``2ДКА'' или ``2DFA'') $A$ --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item начального состояния $q_0 \in Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times \Sigma \cup \{\vdash; \dashv\} \to Q \times \{+1; -1\}$.
        \end{itemize}
        Выполнены следующие условия:
        \begin{itemize}
            \item $\vdash$ и $\dashv$ не лежат в $\Sigma$.
            \item Для любого $q \in Q$
                \[\delta(q, \vdash) = (p, +1) \qquad \text{ и } \qquad \delta(q, \dashv) = (r, -1)\]
                для некоторых $p$ и $r$.
        \end{itemize}
        Входными данными является конечная строка $w = s_1 \dots s_l$, преобразуемая в ленту длины $l+2$, на которой написано
        \[s_0 := \vdash;\; s_1;\; \dots;\; s_l;\; s_{l+1} := \dashv.\]
        Состояние вычисления после $k$ шагов --- это совокупность некоторого состояния автомата $q_k \in Q$ и числа $i_k \in \{0; \dots; l+1\}$. Начальное состояние вычисления (оно же состояние вычисления после $0$ шагов) --- совокупность начального состояния автомата $q_0$ и $i_0 = 0$. Каждым шагом состояние $(q_k, i_k)$ заменяется на $(q_{k+1}, i_{k+1})$, где
        \[(q_{k+1}, i_{k+1} - i_k) := \delta(q_k, s_{i_k}).\]
        Т.е. формально вычисление --- это последовательность состояний $((q_k, i_k))_{k=0}^\infty$, где
        \begin{itemize}
            \item $q_0$ --- начальное состояние автомата,
            \item $i_0 = 0$,
            \item $(q_{k+1}, i_{k+1} - i_k) := \delta(q_k, s_{i_k})$.
        \end{itemize}
        Входная строка принимается автоматом, если есть такое $n$, что $q_n \in F$ и $i_n = l+1$.

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.
    \end{definition}

    \begin{theorem}
        Всякий 2DFA можно свести к DFA.
    \end{theorem}

    \begin{proof}
        \todo[inline]{Написать.}
    \end{proof}

    \begin{theorem}[Майхилла-Нероуда]
        Пусть дан язык $L$. Введём отношение эквивалентности $\equiv_L$ на $\Sigma^*$ по правилу
        \[u \equiv_L v \qquad \Longleftrightarrow \qquad \forall w \in \Sigma^* \quad uw \in L \Leftrightarrow vw \in L.\]
        Тогда $L$ регулярен тогда и только тогда, когда количество классов эквивалентности $|\Sigma^*/{\equiv_L}|$ конечно.
    \end{theorem}

    \begin{proof}
        Пусть $L$ регулярен. Тогда есть минимальный автомат $A$, порождающий язык $L$. Для всякого слова $u$ можно определить состояние $q_u := \delta^*(q_0, u)$. Тогда множество слов $w \in \Sigma^*$, что $uw \in L$ образует алфавит $L_A(q_u)$. Следовательно,
        \[
            u \equiv_L v
            \qquad \Longleftrightarrow \qquad
            L_A(q_u) = L_A(q_v)
            \qquad \Longleftrightarrow \qquad
            q_u = q_v
        \]
        (последний переход верен в силу минимальности $A$). Таким образом
        \[|\Sigma^*/{\equiv_L}| = |Q|, \qquad \Sigma^*/{\equiv_L} = \{\{u \in \Sigma^* \mid \delta^*(q_0, u) = q\}\}_{q \in Q}.\]

        Теперь пусть $\Sigma^*/{\equiv_L}$ конечно. Рассмотрим ДКА
        \[
            A = (\Sigma, \Sigma^*/{\equiv_L}, [\varepsilon]_{\equiv_L}, F, \delta), \text{ где }
            \qquad
            F := \{N \in \Sigma^*/{\equiv_L} \mid N \cap L \neq \varnothing\},
            \qquad
            \delta([u]_{\equiv_L}, a) := [ua]_{\equiv_L}.
        \]
        Несложно проверить, что $\delta$ определено корректно. При этом понятно, что
        \[\delta^*([\varepsilon]_{\equiv_L}, u) = [u]_{\equiv_L}.\]
        Заметим для всякого $N \in \Sigma^*/{\equiv_L}$, что если $N \cap L \neq \varnothing$, то есть $v \in N \cap L$, поэтому $v\varepsilon \in L$, а значит для всякого $u \in N$ верно, что $u\varepsilon \in L$, т.е. $N \subseteq L$. Поэтому понятно, что
        \[
            v \in L
            \qquad \Longleftrightarrow \qquad
            [v]_{\equiv_L} \cap L \neq \varnothing
            \qquad \Longleftrightarrow \qquad
            \delta^*([\varepsilon]_{\equiv_L}, v) \cap L \neq \varnothing
            \qquad \Longleftrightarrow \qquad
            \delta^*([\varepsilon]_{\equiv_L}, v) \in F.
        \]
        Это значит, что $L(A) = L$.
    \end{proof}

    \begin{remark*}
        Заодно мы также показали, что
        \[L = \bigcup_{u \in L} [u]_{\equiv_L}.\]
    \end{remark*}

    \subsection{Вероятностные конечные автоматы}

    \begin{definition}
        \emph{Вероятностный конечный автомат} (также ``ВКА'' или ``PFA'') $A$ --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item начального состояния $q_0 \in Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times \Sigma \to [0; 1]^Q$,
        \end{itemize}
        что для любых $q \in Q$ и $a \in \Sigma$ 
        \[\sum_{p \in Q} \delta(q, a)(p) = 1.\]
        Входными данными является конечная строка $w = s_1 \dots s_n$. Состояние вычисления после $k$ шагов --- это некоторое распределение вероятности между состояниями автомата $f_k: Q \to [0; 1]$. Соответственно, начальное состояние вычисления (оно же состояние вычисления после $0$ шагов) --- распределение $f_0(q) := [q = q_0]$. Каждым шагом состояние $f_k$ заменяется на $f_{k+1} := \sum_{p \in Q} f_k(p) \delta(p, s_{k+1})$. Т.е. формально вычисление --- это последовательность распределений вероятности $(f_k)_{k=0}^n$, где
        \begin{itemize}
            \item $f_0$ --- начальное состояние автомата,
            \item $f_{k+1} := \sum_{p \in Q} f_k(p) \delta(p, s_{k+1})$.
        \end{itemize}
        Распределение $f_n$ называется \emph{результатом вычисления}. Также говорят, что автомат принимает строку $w$, если $\sum_{q \in F} f_n(q) \geqslant \frac{1}{2}$, и отвергает в ином случае.

        \emph{Язык автомата} $A$ или \emph{язык, распознаваемый автоматом} $A$, --- это множество $L(A)$ всех строк, распознаваемых (принимаемых) автоматом $A$. Язык, распознаваемый хоть каким-нибудь автоматом называется \emph{регулярным}.
        
        Также определяют \emph{условие ограниченной ошибки} --- условие, заключающееся в том, что вероятность принятия для любого слова всегда либо $\geqslant \frac{2}{3}$, либо $\leqslant \frac{1}{3}$. Будем рассматривать ВКА, удовлетворяющие этому свойству.
    \end{definition}

    \begin{theorem}
        Для всякого ВКА есть ДКА, распознающий тот же язык.
    \end{theorem}

    \begin{proof}
        Пусть дан ВКА $A$. Пронумеруем его состояния: $M := |Q_A|$, $Q = \{q_i\}_{i=1}^M$. Тогда всякое состояние вычисления есть вектор распределения вероятности $(a_i)_{i=1}^M$ ($a_i$ --- вероятность попадания в $a_i$; $\sum_{i=1}^M a_i = 1$). Также для всякого слова $u \in \Sigma^*$ определим вектора $p(u)$ и $q(u)$, где $p_i(u)$ --- вероятность попадания в вершину $q_i$ по прохождению по слову $u$, а $q_i(u)$ --- вероятность попадания в принимающее состояния, выходя из $q_i$ и идя по слову $u$. В частности, $p(u) \cdot q(v)$ --- вероятность принятия слова $u \cdot v$.
        
        \begin{thlemma}
            Пусть для некоторых слов $u$ и $u'$ верно, что $\|p(u) - p(u')\| := \max_i |p_i(u) - p_i(u')| \leqslant \varepsilon$. Тогда для любого слова $v$
            \[|p(u)q(v) - p(u')q(v)| \leqslant n \varepsilon.\]
        \end{thlemma}

        \begin{proof}
            \begin{align*}
                |p(u)q(v) - p(u')q(v)|
                &= \left|\sum p_i(u)q_i(v) - \sum p_i(u')q_i(v)\right|\\
                &= \left|\sum (p_i(u) - p_i(u'))q_i(v)\right|\\
                &\leqslant \sum |p_i(u) - p_i(u')|q_i(v)\\
                &\leqslant \sum |p_i(u) - p_i(u')|\\
                &\leqslant n \|p(u) - p(u')\|\\
                &= n \varepsilon
            \end{align*}
        \end{proof}

        \begin{corollary}
            Если $\|p(u) - p(u')\| < \frac{1}{3n}$, то из распределений $p(u)$ и $p(u')$ принимаются одинаковые языки, т.е. для всякого слова $v$ верно $uv \in L \Leftrightarrow u'v \in L$.
        \end{corollary}

        \begin{proof}
            Как мы показали разница в вероятностях принятия $uv$ и $u'v$ равна
            \[|p(u)q(v) - p(u')q(v)| \leqslant n \|p(u) - p(u')\| < \frac{1}{3}.\]
            Поскольку $A$ удовлетворяет условию ограниченной ошибки, то вероятности принятия $uv$ и $u'v$ либо обе $\geqslant \frac{2}{3}$, либо обе $\leqslant \frac{1}{3}$, т.е. $uv$ и $u'v$ либо оба принимаются, либо оба не принимаются. Отсюда и выходит требуемое.
        \end{proof}

        Вспомним, что все возможные вектора $p(u)$ лежат в пространстве $[0; 1]^M$ (в реальности можно ещё поставить условие, что сумма координат равна $1$, но это не обязательно). Тогда разобьём его по каждой координате на отрезки длины $1/(3n+1)$; получится $(3n+1)^M$ кубиков, на которые распалось всё пространство $[0; 1]^M$. Как мы показали, для любых двух векторов $p(u)$ и $p(u')$ из одного кубика $\|p(u) - p(u')\|$, а значит языки принимаемые внутри каждого кубика одинаковы (если в кубике есть хоть один вектор $p(u)$).

        Пусть $L$ --- язык, распознаваемый автоматом $A$. Тогда мы имеем, что $|\Sigma^*/{\equiv_L}|$ конечно, а значит есть ДКА, реализующий тот же язык.
    \end{proof}

    \begin{definition}
        \emph{Двухсторонний вероятностный конечный автомат} (также ``2ВКА'' или ``2PFA'') $A$ --- это совокупность
        \begin{itemize}
            \item входного алфавита $\Sigma$,
            \item конечного множества состояний $Q$,
            \item начального состояния $q_0 \in Q$,
            \item множество принимающих состояний $F \subseteq Q$,
            \item функция перехода $\delta: Q \times (\Sigma \cup \{\vdash; \dashv\}) \to [0; 1]^{Q \times \{+1; -1\}}$.
        \end{itemize}
        Выполнены следующие условия:
        \begin{itemize}
            \item $\vdash$ и $\dashv$ не лежат в $\Sigma$.
            \item Для любых $q, p \in Q$
                \[
                    \delta(q, \vdash)(p, -1) = 0
                    \qquad \text{ и } \qquad
                    \delta(q, \dashv)(p, +1) = 0.
                \]
            \item Для любых $q \in Q$ и $a \in \Sigma \cup \{\vdash; \dashv\}$ 
                \[\sum_{t \in Q \times \{+1; -1\}} \delta(q, a)(t) = 1.\]
        \end{itemize}
        Входными данными является конечная строка $w = s_1 \dots s_n$, преобразуемая в ленту длины $l+2$, на которой написано
        \[s_0 := \vdash; s_1; \dots; s_l; s_{l+1} := \dashv.\]
        Автомат также блуждает по полосе как $2DFA$, но каждый раз делает то или иное действие случайно с заданным распределением вероятностей. И как для $PFA$ мы принимаем строку, если вероятность её принять хотя бы $\frac{1}{2}$, а также будем требовать условие ограниченной ошибки.
    \end{definition}

    \begin{example}
        2ВКА распознают больше языков, чем только регулярные. Для примера построим 2ВКА, распознающий $\{a^n b^n\}_{n \in \NN}$.

        Автомат будет работать следующим образом. Он проверит, что строка имеет вид $a^i b^j$, где $i \equiv j \pmod{3}$ (это можно сделать с помощью 2ДКА, а значит и с помощью 2ВКА). Затем автомат будет до бесконечности проходить по всему слову, на каждом символе (отличном от граничных) подбрасывая монетку. Назовём успехом символа $a$ проход, после которого на каком-то символе $a$ выпал орёл, но ни на одном символе $b$ он не выпал; аналогично назовём успех символа $b$. В течение процесса проходов будем считать успехи символов (на оба символ будет хватать счётчиков до 3). Если в какой-то момент выпали 3 успеха одного из символов и ни один успех другого, то будем отвергать строку; если же в какой-то момент у каждого символа будет успеха, но у каждого символа их меньше трёх, то будем принимать строку.

        Теперь покажем, что автомат действительно распознаёт описанный язык. В случае, если строка не подошла шаблону $a^i b^j$, где $i \equiv j \pmod{3}$, строка будет отвергнута с вероятностью $1$ --- правильно. Следовательно, будем рассматривать только строки такого шаблона.
        
        Если $i = j$, то вероятность выпадения успеха $a$ равна вероятности выпадения успеха $b$. Т.е. вероятность выпадения успеха $a$ при условии выпадения хоть какого-нибудь успеха равна $1/2$. Следовательно, вероятность вероятность выпадения хотя бы трёх каких-нибудь успехов равна $1$, а вероятность выпадения 1 успеха $a$ и двух успехов $b$ или наоборот равна $6/8 = 3/4$. Таким образом вероятность принятия равна $3/4 > 2/3$.

        Если $i \neq j$, то WLOG $i > j$, т.е. $i - 3 \geqslant j$. Значит вероятность успеха $a$ при условии выпадения какого-нибудь успеха равна
        \[
            \frac{1/2^j (1 - 1/2^i)}{1/2^j (1 - 1/2^i) + 1/2^i (1 - 1/2^j)}
            = \frac{2^i - 1}{2^i + 2^j - 2}
            \geqslant \frac{2^i - 1}{2^i + 2^{i-3} - 2}
            = \frac{8 \cdot 2^{i-3} - 1}{9 \cdot 2^{i-3} - 2}
            = \frac{8}{9} + \frac{7/9}{9 \cdot 2^{i-3} - 2}
            > \frac{8}{9}.
        \]
        Таким образом вероятность трёх успехов $a$ подряд $>(8/9)^3 > 2/3$. Т.е. вероятность отвержения $>2/3$.

        Итого автомат принимает только описанный язык и удовлетворяет условию ограниченной ошибки.
    \end{example}

    \subsection{Формальные грамматики}

    \begin{definition}
        \emph{Граматика} $G$ --- это совокупность
        \begin{itemize}
            \item $\Sigma$ --- конечный алфавит языка, который мы определяем,
            \item $N$ --- конечный алфавит ``нетерминальных символов'', которые являются переменными задания грамматики,
            \item $R$ --- конечное множество правил грамматики, т.е. конечное подмножество $N \times (\Sigma \cup N)^*$
            \item $S \in N$ --- ``начальный символ'', выделенный нетерминальный, с которого начинается построение.
        \end{itemize}
        
        Определим следующие объекты.
        \begin{itemize}
            \item Отношение $\mathop{\underset{G}{\Rightarrow}}$ (выводимость в один шаг) на $(\Sigma \cup N)^*$ задаётся по правилу:
                \[
                    x \mathop{\underset{G}{\Rightarrow}} y
                    \qquad \Longleftrightarrow \qquad
                    \exists u, v, p, q \in (\Sigma \cup N)^* \colon \quad x = upv \wedge (p \rightarrow q) \in P \wedge y = uqv.
                \]
                (Из $x$ выводится $y$ в один шаг тогда и только тогда, когда $x$ имеет вид $upv$, $y$ --- $uqv$, а $p \to q$ --- правило в грамматике $G$.)
            \item Отношение $\mathop{\overset{*}{\underset{G}{\Rightarrow}}}$ --- рефлексивно-транзитивное замыкание отношения $\mathop{\underset{G}{\Rightarrow}}$.
            \item Сентенциальная форма (также ``sentential form'') --- всякое $w \in (\Sigma \cup N)^*$, что $S \mathop{\overset{*}{\underset{G}{\Rightarrow}}} w$.
            \item \emph{Предложение, построенное грамматикой $G$} --- всякое $w \in \Sigma^*$, являющееся сентенциальной формой.
            \item \emph{Язык грамматики} $G$ --- множество всех предложений.
        \end{itemize}
    \end{definition}

    \begin{example}[синтаксис арифметических выражение]
        Неформально, арифметическое выражение можно построить так.
        \begin{itemize}
            \item Переменная $x$ --- арифметическое выражение.
            \item Число $1$ --- арифметическое выражение.
            \item Если $e$ и $e'$ --- выражения, то $e + e'$ и $e \cdot e'$ --- тоже выражения.
            \item Если $e$ --- выражение, то $(e)$ --- тоже.
        \end{itemize}

        Формально она строится грамматикой $G = (\Sigma, N, R, S)$, где
        \begin{itemize}
            \item $\Sigma := \{x; 1; {+}; {\cdot}; \text{``(''}; \text{``)''}\}$,
            \item $N := \{S\}$,
            \item $R := \{(S, x); (S, 1); (S, S+S); (S, S \cdot S); (S, \text{``}(S)\text{''})\}$.
        \end{itemize}
    \end{example}

    % \section{Сложность вычислений}
    % \section{Теория информация}
\end{document}